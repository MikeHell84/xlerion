import { useEffect, useMemo, useRef, useState } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { X } from 'lucide-react';

// Datos de ciudades e intersecciones (heredados del simulador 2D)
const CITIES_DATA = {
    bogota: {
        name: 'Bogotá',
        peakHours: { morning: [6, 9], evening: [16, 19] },
        intersections: [
            { id: 'av-caracas-72', name: 'Av. Caracas con Calle 72', region: 'Zona Centro', baseLevel: 'Extremo', rates: { N: 0.8, S: 0.7, E: 0.9, W: 0.6 } },
            { id: 'autopista-sur', name: 'Autopista Sur con Calle 38', region: 'Zona Sur', baseLevel: 'Alto', rates: { N: 0.5, S: 0.6, E: 0.4, W: 0.5 } },
            { id: 'carrera-9-calle-19', name: 'Carrera 9 con Calle 19', region: 'Zona Centro', baseLevel: 'Moderado', rates: { N: 0.3, S: 0.35, E: 0.4, W: 0.25 } }
        ]
    },
    medellin: {
        name: 'Medellín',
        peakHours: { morning: [6, 9], evening: [17, 19] },
        intersections: [
            { id: 'cra-49-calle-33', name: 'Carrera 49 con Calle 33', region: 'Centro Comercial', baseLevel: 'Extremo', rates: { N: 0.7, S: 0.8, E: 0.75, W: 0.7 } },
            { id: 'avenida-80', name: 'Avenida 80 con Carrera 51', region: 'Zona Norte', baseLevel: 'Alto', rates: { N: 0.6, S: 0.5, E: 0.55, W: 0.6 } }
        ]
    },
    cali: {
        name: 'Cali',
        peakHours: { morning: [7, 9], evening: [17, 20] },
        intersections: [
            { id: 'cra-5-calle-5', name: 'Carrera 5 con Calle 5', region: 'Centro Histórico', baseLevel: 'Alto', rates: { N: 0.5, S: 0.55, E: 0.6, W: 0.5 } }
        ]
    },
    barranquilla: {
        name: 'Barranquilla',
        peakHours: { morning: [7, 10], evening: [17, 20] },
        intersections: [
            { id: 'cra-53-calle-72', name: 'Carrera 53 con Calle 72', region: 'Centro', baseLevel: 'Moderado', rates: { N: 0.4, S: 0.35, E: 0.45, W: 0.3 } }
        ]
    },
    cartagena: {
        name: 'Cartagena',
        peakHours: { morning: [8, 11], evening: [18, 21] },
        intersections: [
            { id: 'avenida-pedro-heredia', name: 'Avenida Pedro de Heredia', region: 'Manga', baseLevel: 'Moderado', rates: { N: 0.35, S: 0.4, E: 0.3, W: 0.35 } }
        ]
    }
};

// Función para calcular el nivel de tráfico dinámicamente según la hora
const getTrafficLevelByHour = (city, baseLevel, hour) => {
    const cityData = CITIES_DATA[city];
    if (!cityData) return baseLevel;

    const { morning, evening } = cityData.peakHours;
    const isMorningPeak = hour >= morning[0] && hour <= morning[1];
    const isEveningPeak = hour >= evening[0] && hour <= evening[1];

    // MADRUGADA: 00:00 a 05:59 (poco tráfico)
    // VALLE: 12:00 a 14:00 (descanso del mediodía)
    // NOCHE: 20:00 a 23:59 (disminuye tráfico)
    const isMidnight = hour >= 0 && hour < 6;  // Madrugada (menos tráfico)
    const isLunchValley = hour >= 12 && hour < 14;  // Valle del almuerzo
    const isNight = hour >= 20 && hour < 24;  // Noche (menos tráfico)
    const isValley = isMidnight || isLunchValley || isNight;

    // Matriz de transformación de niveles según hora del día
    const levelTransform = {
        'Extremo': {
            peak: 'Extremo',
            normal: 'Alto',
            valley: 'Bajo'
        },
        'Alto': {
            peak: 'Extremo',
            normal: 'Alto',
            valley: 'Bajo'
        },
        'Moderado': {
            peak: 'Alto',
            normal: 'Moderado',
            valley: 'Mínimo'
        },
        'Bajo': {
            peak: 'Moderado',
            normal: 'Bajo',
            valley: 'Mínimo'
        }
    };

    const transform = levelTransform[baseLevel] || levelTransform['Moderado'];

    // Especial: si es madrugada (0-5), devolver MÍNIMO siempre
    if (isMidnight) return 'Mínimo';

    if (isMorningPeak || isEveningPeak) return transform.peak;
    if (isValley) return transform.valley;
    return transform.normal;
};

// Tabla de parámetros de spawn según nivel de tráfico
const getSpawnParamsByLevel = (trafficLevel) => {
    const params = {
        'Extremo': {
            spawnInterval: 4,      // Genera cada 4 ticks (~0.067s)
            spawnChanceMultiplier: 1.8,  // 180% de la tasa base
            maxVehiclesPerLane: 25,  // Máximo de vehículos por carril
            description: 'LLENO - Todas las vías saturadas'
        },
        'Alto': {
            spawnInterval: 8,      // Genera cada 8 ticks (~0.133s)
            spawnChanceMultiplier: 1.2,  // 120% de la tasa base
            maxVehiclesPerLane: 18,
            description: 'INTENSO - Mucho tráfico'
        },
        'Moderado': {
            spawnInterval: 12,     // Genera cada 12 ticks (~0.2s) - default
            spawnChanceMultiplier: 0.8,  // 80% de la tasa base
            maxVehiclesPerLane: 12,
            description: 'NORMAL - Tráfico regular'
        },
        'Bajo': {
            spawnInterval: 16,     // Genera cada 16 ticks (~0.267s)
            spawnChanceMultiplier: 0.5,  // 50% de la tasa base
            maxVehiclesPerLane: 8,
            description: 'BAJO - Pocos vehículos'
        },
        'Mínimo': {
            spawnInterval: 24,     // Genera cada 24 ticks (~0.4s)
            spawnChanceMultiplier: 0.2,  // 20% de la tasa base
            maxVehiclesPerLane: 3,
            description: 'MÍNIMO - Casi sin tráfico (noche)'
        }
    };
    return params[trafficLevel] || params['Moderado'];
};

// Función para calcular el multiplicador de velocidad durante transiciones amarillas
const getYellowTransitionSpeedMultiplier = (direction, yellowTransition) => {
    const trans = yellowTransition[direction];

    if (!trans.isYellow || !trans.yellowStartTime) {
        return 1.0; // Sin cambios si no estamos en transición
    }

    const now = performance.now();
    const elapsedMs = now - trans.yellowStartTime;
    const yellowDuration = trans.yellowDuration || 3000;
    const progress = Math.min(1, elapsedMs / yellowDuration); // 0 a 1

    if (trans.transitionType === 'accelerate') {
        // Rojo -> Amarillo -> Verde: acelerar gradualmente
        // progress 0 = velocidad normal (1.0)
        // progress 1 = velocidad máxima (1.5x)
        return 1.0 + (progress * 0.5); // De 1.0 a 1.5
    } else if (trans.transitionType === 'decelerate') {
        // Verde -> Amarillo -> Rojo: desacelerar gradualmente
        // progress 0 = velocidad normal (1.0)
        // progress 1 = velocidad mínima (0.5x)
        return 1.0 - (progress * 0.5); // De 1.0 a 0.5
    }

    return 1.0;
};

export default function ThreeJSIntersection() {
    const mountRef = useRef(null);
    const sceneRef = useRef(null);
    const tickRef = useRef(0);
    const tickAccumulatorRef = useRef(0);
    const vehiclesRef = useRef({ N: [], S: [], E: [], W: [] });
    const currentPhaseRef = useRef('NS');
    const lastModeRef = useRef('classic');
    const lastPriorityAxisRef = useRef('NS');
    const adaptivePhaseTargetRef = useRef({ axis: 'NS', initialQueue: 0 });
    const statsRef = useRef({ totalReleased: 0, efficiency: 0 });
    const releasedTotalsRef = useRef({ N: 0, S: 0, E: 0, W: 0 });
    const lastPhaseReleasedRef = useRef({ N: 0, S: 0, E: 0, W: 0, total: 0 });
    const triggerZonesRef = useRef({});
    const exitTriggerZonesRef = useRef({});

    // Sistema de transiciones en modo clásico: maneja la fase amarilla de transición
    const classicPhaseStateRef = useRef({
        currentPhase: 'NS', // Fase activa: 'NS' o 'EW'
        phaseState: 'green', // Estado: 'green', 'yellow' (transición), 'red'
        yellowStartTime: null, // Cuándo comenzó el amarillo
        yellowDuration: 3000  // 3 segundos de amarillo para transición
    });

    // Sistema de transiciones en modo inteligente: detecta cuando cambiar a amarillo
    const intelligentYellowStateRef = useRef({
        isTransitioning: false, // Si estamos en fase de transición
        nextPhase: null, // Próxima fase a cambiar (NS o EW)
        nextGreenDirs: null, // Próximas direcciones a poner en verde
        yellowStartTime: null, // Cuándo empezó la transición amarilla
        vehiclesExited: 0, // Conteo de vehículos que han salido
        targetExitCount: 0 // Cuántos vehículos esperamos que salgan (5, 10, etc.)
    });

    // Helper to support multiple triggers per direction (per-lane triggers).
    const getEntryTriggersForDir = (dir) => {
        const v = triggerZonesRef.current?.[dir];
        return Array.isArray(v) ? v : (v ? [v] : []);
    };
    const _getExitTriggersForDir = (dir) => {
        const v = exitTriggerZonesRef.current?.[dir];
        return Array.isArray(v) ? v : (v ? [v] : []);
    };
    const exitDebugMeshesRef = useRef({});
    const resetGreenWaveRequestRef = useRef(false);
    const testForceModeRef = useRef(null);
    const waitingHistoryRef = useRef([]); // historial de últimos recuentos por dirección
    const lastMeasuredCountsRef = useRef({ N: 0, S: 0, E: 0, W: 0 });
    const lastMeasurementValidRef = useRef(true); // si la última medición provino de triggers/colliders reales
    const lastMeasurementEstimatedRef = useRef(false); // si la última medición usó fallback/estimado
    const lastChosenDirsRef = useRef([]); // últimas direcciones elegidas por GreenWave (para HUD)
    const debugForceShowArrowsRef = useRef(false); // default: do not force-show arrows in production/demo
    const debugShowCollidersRef = useRef(false);
    // Performance/efficiency tracking refs for classic vs intelligent
    const perfRef = useRef({
        classic: { waitTimes: [], lastCycle: null, greenOpenWithVehicles: 0, greenOpenWasted: 0, history: [] },
        intelligent: { waitTimes: [], lastCycle: null, greenOpenWithVehicles: 0, greenOpenWasted: 0, history: [] }
    });
    // Accumuladores persistentes para el panel de eficiencia (no se reinician cada tick)
    const efficiencyStatsRef = useRef({
        classic: {
            totalLiberados: { N: 0, S: 0, E: 0, W: 0, total: 0 },
            totalEnCola: { N: 0, S: 0, E: 0, W: 0 },
            tiempoEsperaAcumulado: { N: 0, S: 0, E: 0, W: 0 },
            prevSnapshotTotalLiberados: 0
        },
        intelligent: {
            totalLiberados: { N: 0, S: 0, E: 0, W: 0, total: 0 },
            totalEnCola: { N: 0, S: 0, E: 0, W: 0 },
            tiempoEsperaAcumulado: { N: 0, S: 0, E: 0, W: 0 },
            prevSnapshotTotalLiberados: 0
        }
    });
    // Track red->green intervals per mode for new metrics (ms)
    const redToGreenStatsRef = useRef({
        classic: { count: 0, totalMs: 0, sumSq: 0 },
        intelligent: { count: 0, totalMs: 0, sumSq: 0 }
    });
    const prevSemStateRef = useRef({ N: 'red', S: 'red', E: 'red', W: 'red' });
    const greenActiveInfoRef = useRef({ N: null, S: null, E: null, W: null });
    const releasedSinceLastEvalRef = useRef(0);
    const prevTotalReleasedRef = useRef(0);
    const laneToSemaphoreMapRef = useRef({});

    // Sistema de transición amarilla: controla la aceleración/desaceleración gradual
    const yellowTransitionRef = useRef({
        N: { isYellow: false, yellowStartTime: null, yellowDuration: 3000 }, // 3 segundos en amarillo
        S: { isYellow: false, yellowStartTime: null, yellowDuration: 3000 },
        E: { isYellow: false, yellowStartTime: null, yellowDuration: 3000 },
        W: { isYellow: false, yellowStartTime: null, yellowDuration: 3000 }
    });
    const lastKnownTotalsRef = useRef({ classic: 0, intelligent: 0 });
    // Debug counters for exits — global, per-mode
    const exitCountRef = useRef({ classic: 0, intelligent: 0 });
    const exitLogRef = useRef([]); // recent { mode, dir, uuid, ts }
    // Per-run counters to avoid clobbering global cumulative counters
    const currentRunCountersRef = useRef({ classic: 0, intelligent: 0 });
    // Mantiene el estado del accidente actual (incluye orientación para render diferenciado)
    const accidentRef = useRef({ active: false, location: null, orientation: null, startTick: 0 });

    // Tiempo acumulado de espera por dirección (para prioridad por justicia temporal)
    const waitingTimeByDirectionRef = useRef({ N: 0, S: 0, E: 0, W: 0 });

    // Flag para rastrear si el modo inteligente ya fue inicializado (para poner en rojo solo al inicio)
    const intelligentModeInitializedRef = useRef(false);
    const WAITING_TIME_THRESHOLD = 120; // ticks antes de otorgar prioridad por tiempo de espera
    const WAITING_TIME_MAX = 300; // ticks máximo antes de forzar prioridad absoluta

    const [selectedCity, setSelectedCity] = useState('bogota');
    const [selectedIntersection, setSelectedIntersection] = useState('av-caracas-72');
    const [selectedHour, setSelectedHour] = useState(8);

    const simConfigRef = useRef({ city: 'bogota', intersection: 'av-caracas-72', hour: 8 });

    const [isRunning, setIsRunning] = useState(true);

    // Estados para modales técnicos
    const [showAlgorithm, setShowAlgorithm] = useState(false);
    const [showAlgorithmAuth, setShowAlgorithmAuth] = useState(false);
    const [algorithmPassword, setAlgorithmPassword] = useState('');
    const [algorithmAuthError, setAlgorithmAuthError] = useState('');
    const [showTechnicalDoc, setShowTechnicalDoc] = useState(false);
    const [showTechDocAuth, setShowTechDocAuth] = useState(false);
    const [techDocPassword, setTechDocPassword] = useState('');
    const [techDocAuthError, setTechDocAuthError] = useState('');
    const [showIPProtection, setShowIPProtection] = useState(false);
    const [isPanelExpanded, setIsPanelExpanded] = useState(false);
    const [effPanelOpen, setEffPanelOpen] = useState(true);
    const [configChanged, setConfigChanged] = useState(false);
    const [controlsPanelOpen, setControlsPanelOpen] = useState(false);
    const [legendPanelOpen, setLegendPanelOpen] = useState(false);
    // Expose actions defined inside the Three.js init effect to the JSX handlers
    const actionsRef = useRef({});
    const [phase, setPhase] = useState('NS');
    const [dynamicTrafficLevel, setDynamicTrafficLevel] = useState('Extremo');
    const [trafficLightMode, setTrafficLightMode] = useState('classic'); // 'classic', 'intelligent' (GreenWave unificado)
    // Ref for animation loop to avoid stale closure capturing trafficLightMode
    const trafficModeRef = useRef(trafficLightMode);
    const phaseTimerRef = useRef({ remaining: 60, lastUpdate: performance.now() });
    const _phaseStartQueueRef = useRef({ NS: 0, EW: 0 }); // Trackea la cola inicial cuando entra a cada fase (para 50% rule) - puede usarse después
    // Matriz dinámica de distribución: captura snapshot de vehículos en cola al iniciar fase
    const phaseDistributionMatrixRef = useRef({ N: 0, S: 0, E: 0, W: 0, total: 0, proportions: { N: 0, S: 0, E: 0, W: 0 } });
    // Sistema de generaciones: vehículos capturados al inicio de fase vs nuevos que llegan
    const phaseGenerationRef = useRef(0); // Incrementa cada vez que cambia de fase
    const capturedVehicleIdsRef = useRef(new Set()); // IDs de vehículos capturados al inicio de fase
    const modeDisplaysRef = useRef({}); // Sprites sobre cada semáforo
    const [isTrafficPanelExpanded, setIsTrafficPanelExpanded] = useState(false);
    const [showSemInfo, setShowSemInfo] = useState(false);
    const [showAdvancedControls, setShowAdvancedControls] = useState(false);
    // NOTE: `sessionMode` removed — not used. Add small helpers to reduce lint noise.

    // Minimal no-op logger to handle previously-empty catch blocks without removing them
    const _noop = (/* err */) => { /* intentionally empty for debug-safe no-op */ };

    const getEffectiveMode = () => {
        if (testForceModeRef.current) return testForceModeRef.current;
        return (trafficModeRef.current === 'greenwave') ? 'intelligent' : trafficModeRef.current;
    };

    // Lightweight helper stubs used by the test runner/greenwave logic.
    // These are intentionally small and conservative: they avoid undefined-symbol
    // runtime errors while preserving existing behavior. Replace with full
    // implementations if more precise state-reset or measurement is required.
    const _resetVehiclesStateForGreenWave = () => {
        try {
            // reset simple counters and refs used by GreenWave tests
            releasedSinceLastEvalRef.current = 0;
            prevTotalReleasedRef.current = 0;
            waitingHistoryRef.current = [];
        } catch (e) { _noop(e); }
    };

    const _measureWaitingQueues = () => {
        try {
            // return a conservative snapshot (fallback) of queue lengths
            const v = vehiclesRef.current || { N: [], S: [], E: [], W: [] };
            return { N: v.N.length, S: v.S.length, E: v.E.length, W: v.W.length };
        } catch (e) { _noop(e); return { N: 0, S: 0, E: 0, W: 0 }; }
    };
    const [accidentActive, setAccidentActive] = useState(false);
    const [accidentLocation, setAccidentLocation] = useState(null);
    const [debugLogs, setDebugLogs] = useState([]);
    const [showDebugPanel, setShowDebugPanel] = useState(false);
    // Test runner UI/state
    const [showTestModal, setShowTestModal] = useState(false);
    const [testDurationSec, setTestDurationSec] = useState(30);
    const [testRunning, setTestRunning] = useState(false);
    const [testResults, setTestResults] = useState(null);
    const [testSeedCount, setTestSeedCount] = useState(5);
    // Canvas ref and drawing helper for Test Modal (placed after testResults state)
    const comparisonCanvasRef = useRef(null);
    const [testCurrentMode, setTestCurrentMode] = useState(null);
    const [testModeProgress, setTestModeProgress] = useState(0);
    const [testProgressByMode, setTestProgressByMode] = useState({ classic: 0, intelligent: 0 });
    const [testInternalStatus, setTestInternalStatus] = useState({ warmup: '', mode: '', info: '' });

    const waitWithProgress = (ms, onProgress = () => { }) => {
        if (!ms || ms <= 0) {
            try { onProgress(1); } catch (_e) { }
            return Promise.resolve();
        }
        const start = performance.now();
        return new Promise((resolve) => {
            let rafId = null;
            const step = () => {
                const now = performance.now();
                const elapsed = now - start;
                const p = Math.min(1, elapsed / ms);
                try { onProgress(p); } catch (_e) { }
                if (elapsed >= ms) {
                    resolve();
                    return;
                }
                rafId = requestAnimationFrame(step);
            };
            rafId = requestAnimationFrame(step);
        });
    };
    // Live UI state to show exit counters while a test runs
    const [liveExitCounts, setLiveExitCounts] = useState({ classic: 0, intelligent: 0 });
    const [liveRecentExits, setLiveRecentExits] = useState([]);

    const drawComparisonChart = (canvas, data) => {
        try {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            // HiDPI support
            const DPR = (typeof window !== 'undefined' && window.devicePixelRatio) ? window.devicePixelRatio : 1;
            const CSS_W = 920;
            const CSS_H = 420;
            canvas.width = Math.round(CSS_W * DPR);
            canvas.height = Math.round(CSS_H * DPR);
            canvas.style.width = CSS_W + 'px';
            canvas.style.height = CSS_H + 'px';
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            // clear
            ctx.clearRect(0, 0, CSS_W, CSS_H);
            // background
            ctx.fillStyle = '#071014';
            ctx.fillRect(0, 0, CSS_W, CSS_H);

            const padding = 18;
            const areaW = CSS_W - padding * 2;
            const areaH = CSS_H - padding * 2;

            // Metrics to show (label, higherIsBetter)
            const metrics = [
                { key: 'cumulativeReleased', label: 'Total liberados (acumul.)', higherBetter: true },
                { key: 'effReleasedDelta', label: 'Liberados (duración prueba)', higherBetter: true },
                { key: 'avgWaitSec', label: 'Espera media (s)', higherBetter: false },
                { key: 'queueEndTotal', label: 'Total en cola (fin)', higherBetter: false }
            ];

            // Extract numeric values and determine scale
            const classic = data.results.classic || {};
            const intelligent = data.results.intelligent || {};

            const values = metrics.map(m => {
                const a = Number(classic[m.key] || 0);
                const b = Number(intelligent[m.key] || 0);
                return { a, b, label: m.label, higherBetter: m.higherBetter };
            });

            // Find max to scale bars, but protect against zero
            let maxVal = 1;
            values.forEach(v => { maxVal = Math.max(maxVal, Math.abs(v.a) || 0, Math.abs(v.b) || 0); });

            const rowH = Math.floor(areaH / values.length);
            const barMaxW = Math.floor(areaW * 0.55);

            // Draw title
            ctx.fillStyle = '#8ee7f6';
            ctx.font = '16px Inter, Arial';
            ctx.fillText('Comparativa: Clásico vs Inteligente', padding, 14);

            // Draw each metric row with stacked (non-overlapping) bars per metric
            values.forEach((v, i) => {
                const yTop = padding + 36 + i * rowH;
                // Label
                ctx.fillStyle = '#9beaf2';
                ctx.font = '13px Inter, Arial';
                ctx.fillText(v.label, padding, yTop + 12);

                // Scaling: clamp between 0..1
                const aNorm = (maxVal > 0) ? Math.min(1, Math.abs(v.a) / maxVal) : 0;
                const bNorm = (maxVal > 0) ? Math.min(1, Math.abs(v.b) / maxVal) : 0;
                // For metrics where lower is better, invert the visual scale so smaller appears 'better'
                const aScaled = v.higherBetter ? aNorm : (1 - aNorm);
                const bScaled = v.higherBetter ? bNorm : (1 - bNorm);
                const aW = Math.max(2, Math.round(aScaled * barMaxW));
                const bW = Math.max(2, Math.round(bScaled * barMaxW));

                // Bars positions (stacked: classic on top, intelligent below)
                const barX = padding + 260;
                const barHeight = Math.min(28, Math.floor(rowH * 0.35));
                const topY = yTop + 6;
                const botY = topY + barHeight + 6;

                // Background bar area (subtle)
                ctx.fillStyle = 'rgba(255,255,255,0.03)';
                ctx.fillRect(barX, topY, barMaxW, barHeight);
                ctx.fillRect(barX, botY, barMaxW, barHeight);

                // Classic bar (cyan)
                ctx.fillStyle = '#06b6d4';
                ctx.fillRect(barX, topY, aW, barHeight);
                // Classic value label near end
                ctx.fillStyle = '#cfeff3';
                ctx.font = '12px Inter, Arial';
                const aText = (v.a == null ? 'N/A' : String(v.a));
                const aLabelX = barX + aW + 8;
                ctx.fillText(`Clásico: ${aText}`, aLabelX, topY + (barHeight / 1.3));

                // Intelligent bar (lime)
                ctx.fillStyle = '#7efc6a';
                ctx.fillRect(barX, botY, bW, barHeight);
                // Intelligent value label
                const bText = (v.b == null ? 'N/A' : String(v.b));
                const bLabelX = barX + bW + 8;
                ctx.fillStyle = '#cfeff3';
                ctx.fillText(`Inteligente: ${bText}`, bLabelX, botY + (barHeight / 1.3));
            });

            // Footer: winner and scores
            const winner = data.winner || '—';
            const classicScore = data.scores?.classic ?? 0;
            const intelScore = data.scores?.intelligent ?? 0;
            ctx.fillStyle = '#9beaf2';
            ctx.font = '13px Inter, Arial';
            ctx.fillText(`Ganador: ${winner.toUpperCase()} — Scores (C:${Math.round(classicScore)} / I:${Math.round(intelScore)})`, padding, CSS_H - 8);
        } catch (err) {
            try { console.warn('drawComparisonChart error', err); } catch (e) { _noop(e); }
        }
    };

    // When testResults state changes (setTestResults), draw chart into canvas
    useEffect(() => {
        let liveTimer = null;
        if (!testResults) return;
        let attempts = 0;
        const tryDraw = () => {
            const canvas = comparisonCanvasRef.current;
            if (canvas) {
                try {
                    drawComparisonChart(canvas, testResults);
                    return;
                } catch (e) { console.warn('chart draw failed', e); }
            }
            attempts++;
            if (attempts < 6) {
                // retry a few times to wait for DOM mount
                setTimeout(tryDraw, 120);
            }
        };
        tryDraw();
        return () => { attempts = 999; };
    }, [testResults]);

    // Update live counters periodically while test is running so user can see activity
    useEffect(() => {
        let iv = null;
        if (testRunning) {
            iv = setInterval(() => {
                try {
                    setLiveExitCounts({ classic: exitCountRef.current.classic || 0, intelligent: exitCountRef.current.intelligent || 0 });
                    setLiveRecentExits((exitLogRef.current || []).slice(0, 8));
                } catch (e) { _noop(e); }
            }, 300);
        }
        return () => { if (iv) clearInterval(iv); };
    }, [testRunning]);

    // While a test runs, push a periodic debug trace every 1s to capture mode and counters
    useEffect(() => {
        let tv = null;
        if (testRunning) {
            tv = setInterval(() => {
                try {
                    const tm = trafficModeRef.current;
                    const tl = trafficLightMode;
                    const forced = testForceModeRef.current;
                    const last = lastModeRef.current;
                    const counts = { ...(exitCountRef.current || {}) };
                    pushDebug && pushDebug(`[Trace] trafficModeRef=${tm} trafficLightMode=${tl} testForce=${forced} lastMode=${last} exits=${JSON.stringify(counts)}`);
                } catch (e) { _noop(e); }
            }, 1000);
        }
        return () => { if (tv) clearInterval(tv); };
    }, [testRunning, trafficLightMode]);

    // Formatting helpers for test results table
    const formatMetricValue = (val, key) => {
        if (val == null || Number.isNaN(val)) return '—';
        if (key === 'avgWaitSec') return (Math.round(Number(val) * 10) / 10).toFixed(1);
        if (key === 'cumulativeReleased' || key === 'effReleasedDelta' || key === 'releasedDelta' || key === 'queueEndTotal') return String(Math.round(Number(val)));
        return String(val);
    };

    const computeDeltaPercent = (a, b) => {
        try {
            const na = Number(a); const nb = Number(b);
            if (!Number.isFinite(na) || !Number.isFinite(nb) || na === 0) return null;
            const p = ((nb - na) / Math.abs(na)) * 100;
            return (Math.round(p * 10) / 10);
        } catch (e) { return null; }
    };

    // Añadir línea al panel de depuración (mantiene últimas 8 entradas)
    const pushDebug = (msg) => {
        try {
            const time = new Date().toLocaleTimeString();
            setDebugLogs(prev => {
                const next = [...prev, `${time} ${msg}`];
                return next.slice(-8);
            });
        } catch (err) {
            console.warn('pushDebug error', err);
        }
    };

    // Async helper: run tests for each mode and return results
    async function runModeComparisonTests(durationSeconds = 15) {
        const modes = ['classic', 'intelligent'];
        const results = {};

        // Reset live exit counters/logs so the UI no se congele con valores viejos
        try {
            exitCountRef.current = { classic: 0, intelligent: 0 };
            currentRunCountersRef.current = { classic: 0, intelligent: 0 };
            exitLogRef.current = [];
            setLiveExitCounts({ classic: 0, intelligent: 0 });
            setLiveRecentExits([]);
        } catch (e) { _noop(e); }

        const wait = (ms) => new Promise(res => setTimeout(res, ms));

        try { setTestInternalStatus({ warmup: 'Preparando condiciones base', mode: '', info: 'Restableciendo estado y contadores' }); } catch (e) { _noop(e); }

        // Explicit warm-up helper used before measuring a mode.
        const warmUpMode = async (mode, durationSeconds, testSpeed, seed) => {
            try { pushDebug(`[TestRunner] warmUpMode start mode=${mode} duration=${durationSeconds}s speed=${testSpeed} seed=${seed}`); } catch (e) { _noop(e); }
            try {
                const speedLabel = (typeof testSpeed === 'number' && Number.isFinite(testSpeed)) ? `x${(Math.round(testSpeed * 10) / 10).toFixed(1)}` : 'default';
                setTestInternalStatus(prev => ({ ...(prev || {}), mode: `Forzando modo ${mode} (${speedLabel})`, info: 'Precalentamiento con tráfico extremo y semilla alta' }));
            } catch (e) { _noop(e); }
            try {
                setTrafficLightMode(mode);
                trafficModeRef.current = mode;
            } catch (e) { _noop(e); }
            try { setSpeedMultiplier(testSpeed); speedMultiplierRef.current = testSpeed; } catch (e) { _noop(e); }

            // Seed traffic if requested
            try {
                // For test warm-up, force a heavy seed baseline of 300 vehicles total (~75 por dirección)
                const seedCountLocal = Math.max(0, Number(seed) || 0, 75);
                if (seedCountLocal > 0) {
                    try { pushDebug(`[TestRunner] Seeding ${seedCountLocal} vehicles per direction for warm-up mode=${mode}`); } catch (e) { _noop(e); }
                    try { setTestInternalStatus(prev => ({ ...(prev || {}), warmup: `Sembrando ${seedCountLocal} vehículos por dirección (modo ${mode})` })); } catch (e) { _noop(e); }
                    const dirs = ['N', 'S', 'E', 'W'];
                    // Place seeded vehicles closer to the stop line so they quickly participate
                    const stopLineOffset = Math.max(0, Math.round(STOP_LINE_PROGRESS * STREET_LENGTH) - 2);
                    for (let s = 0; s < seedCountLocal; s++) {
                        dirs.forEach(dir => {
                            try {
                                // Create vehicle positioned near the queue/stop-line so it triggers queue quickly
                                const offset = Math.max(0, stopLineOffset - (s * VEHICLE_SPAWN_GAP));
                                const v = createVehicle('car', dir, offset);
                                // set progress so the main loop places the vehicle at the intended offset
                                try { v.userData.progress = Math.min(0.999, Math.max(0, offset / STREET_LENGTH)); } catch (e) { _noop(e); }
                                // mark an entryTime so wait-time calculations are possible even for seeded vehicles
                                try { v.userData.entryTime = performance.now(); } catch (e) { v.userData.entryTime = Date.now(); }
                                // if seeded vehicle is beyond the queue trigger, mark queueTriggered so it's counted as waiting
                                try {
                                    if (v.userData.progress >= QUEUE_TRIGGER_PROGRESS) {
                                        v.userData.queueTriggered = true;
                                    }
                                } catch (e) { _noop(e); }
                                vehiclesRef.current[dir].push(v);
                                try { pushDebug(`[TestRunner] seeded vehicle ${v.uuid} dir=${dir} progress=${v.userData.progress.toFixed(3)}`); } catch (e) { _noop(e); }
                            } catch (e) {
                                try { spawnVehicle(dir); } catch (e2) { _noop(e2); }
                            }
                        });
                    }
                    try { setTestInternalStatus(prev => ({ ...(prev || {}), warmup: `Sembrado completado (${seedCountLocal} por dirección)`, info: `Warm-up ${durationSeconds}s con tráfico extremo` })); } catch (e) { _noop(e); }
                }
            } catch (e) { _noop(e); }

            // Request a GreenWave reset so intelligent mode evaluates immediately
            try { resetGreenWaveRequestRef.current = true; } catch (e) { _noop(e); }

            // Wait the warm-up duration (real seconds) to allow accelerated sim to stabilize
            await wait(Math.max(500, Math.round(durationSeconds * 1000)));
            try { pushDebug(`[TestRunner] warmUpMode end mode=${mode}`); } catch (e) { _noop(e); }
            try { setTestInternalStatus(prev => ({ ...(prev || {}), info: `Warm-up finalizado para modo ${mode}` })); } catch (e) { _noop(e); }
            // After warm-up, capture an instant measurement to help diagnostics
            try {
                const instant = measureWaitingQueues();
                try { pushDebug(`[TestRunner] warmUp instantWaiting mode=${mode} -> ${JSON.stringify(instant)}`); } catch (e) { _noop(e); }
                if (mode === 'intelligent' && !accidentRef.current.active) {
                    try { applyGreenWaveDynamicLogic(instant); } catch (e) { _noop(e); }
                }
            } catch (e) { _noop(e); }
        };

        // Compute a speed multiplier so that CLASSIC_PHASE_SECONDS are simulated
        // within the user-provided `durationSeconds` real seconds. This accelerates
        // both modes equally so comparisons are fair.
        const testSpeed = Math.max(1, (CLASSIC_PHASE_SECONDS / Math.max(1, durationSeconds)));
        const prevSpeed = speedMultiplierRef.current || 1;
        try {
            setSpeedMultiplier(testSpeed);
            // ensure immediate effect for the animation loop
            try { speedMultiplierRef.current = testSpeed; } catch (e) { _noop(e); }
        } catch (e) { _noop(e); }

        for (const mode of modes) {
            try {
                // Reset perf arrays for this mode to avoid noise
                if (perfRef.current && perfRef.current[mode]) {
                    perfRef.current[mode].waitTimes = [];
                    perfRef.current[mode].greenOpenWithVehicles = 0;
                    perfRef.current[mode].greenOpenWasted = 0;
                }

                // Reset vehicles to a known state and perform an explicit warm-up
                try { resetVehiclesStateForGreenWave(); } catch (e) { _noop(e); }

                // Ensure warm-up conditions are identical for both modes: force extreme traffic level and peak hour
                const prevSelectedHour = selectedHour;
                const prevDynamicLevel = dynamicTrafficLevel;
                try {
                    // set peak hour and extreme dynamic level so getCurrentRates returns high spawn rates
                    try { setSelectedHour(8); simConfigRef.current.hour = 8; } catch (e) { _noop(e); }
                    try { setDynamicTrafficLevel('Extremo'); } catch (e) { _noop(e); }
                } catch (e) { _noop(e); }

                try {
                    setTestInternalStatus({ warmup: 'Forzando hora pico 8:00 y nivel Extremo', mode: `Preparando modo ${mode}`, info: 'Semilla mínima de 75 vehículos por dirección + boost de spawn' });
                } catch (e) { _noop(e); }

                try {
                    // explicit warm-up helper will set mode, speed, seed and request reset
                    // Force test mode so animation loop does not override during warm-up/measurement
                    try { testForceModeRef.current = mode; } catch (e) { _noop(e); }
                    await warmUpMode(mode, durationSeconds, testSpeed, testSeedCount);
                } catch (e) { _noop(e); }

                // restore previous hour/level after warm-up for next iterations (will be overridden again per-mode)
                try { setSelectedHour(prevSelectedHour); simConfigRef.current.hour = prevSelectedHour; } catch (e) { _noop(e); }
                try { setDynamicTrafficLevel(prevDynamicLevel); } catch (e) { _noop(e); }

                try { setTestInternalStatus(prev => ({ ...(prev || {}), warmup: 'Warm-up completado', mode: `Midiendo modo ${mode}`, info: `Recogiendo métricas durante ${durationSeconds}s` })); } catch (e) { _noop(e); }

                // Ensure per-run exit counters for this mode start at zero for the measurement
                try { currentRunCountersRef.current[mode] = 0; } catch (e) { _noop(e); }

                // Expose current mode/progress for UI (progress bar/countdown)
                try {
                    setTestCurrentMode(mode);
                    setTestModeProgress(0);
                    setTestProgressByMode(prev => ({ ...(prev || {}), [mode]: 0 }));
                } catch (e) { _noop(e); }

                // If we're about to measure intelligent mode, force an immediate GreenWave evaluation
                if (mode === 'intelligent') {
                    try {
                        pushDebug && pushDebug('[TestRunner] Forcing GreenWave immediate evaluation before measurement');
                    } catch (e) { _noop(e); }
                    try {
                        // Make sure state refs/states reflect intelligent mode
                        setTrafficLightMode('intelligent');
                        trafficModeRef.current = 'intelligent';
                        // force all semaphores to red and request reset so evaluation runs in animation loop
                        try { resetGreenWaveRequestRef.current = true; } catch (e) { _noop(e); }
                        try { updateTrafficLights([], 'green'); } catch (e) { _noop(e); }
                        const instantWaiting = typeof measureWaitingQueues === 'function' ? measureWaitingQueues() : null;
                        try { pushDebug && pushDebug('[TestRunner] forced instantWaiting -> ' + JSON.stringify(instantWaiting)); } catch (e) { _noop(e); }
                        try { if (!accidentRef.current.active) applyGreenWaveDynamicLogic(instantWaiting); } catch (e) { _noop(e); }
                        // ensure lastModeRef is set so animation loop understands we're in intelligent
                        try { lastModeRef.current = 'intelligent'; } catch (e) { _noop(e); }
                    } catch (e) { _noop(e); }
                }

                const baseline = {
                    totalReleased: statsRef.current.totalReleased || 0,
                    effTotalLiberados: (efficiencyStatsRef.current && efficiencyStatsRef.current[mode] && efficiencyStatsRef.current[mode].totalLiberados && efficiencyStatsRef.current[mode].totalLiberados.total) || 0,
                    perfWaitLen: (perfRef.current && perfRef.current[mode] && perfRef.current[mode].waitTimes) ? perfRef.current[mode].waitTimes.length : 0
                };

                // Run for durationSeconds (with progress updates so UI can show countdown)
                const runMs = Math.max(1000, Math.round(durationSeconds * 1000));
                await waitWithProgress(runMs, (p) => {
                    try {
                        const percent = Math.round(p * 100);
                        setTestModeProgress(percent);
                        setTestProgressByMode(prev => ({ ...(prev || {}), [mode]: percent }));
                    } catch (e) { _noop(e); }
                });

                // Snapshot end
                const end = {
                    totalReleased: statsRef.current.totalReleased || 0,
                    effTotalLiberados: (efficiencyStatsRef.current && efficiencyStatsRef.current[mode] && efficiencyStatsRef.current[mode].totalLiberados && efficiencyStatsRef.current[mode].totalLiberados.total) || 0,
                    perfWaits: (perfRef.current && perfRef.current[mode] && perfRef.current[mode].waitTimes) ? perfRef.current[mode].waitTimes.slice(baseline.perfWaitLen) : [],
                    queueEnd: (typeof measureWaitingQueues === 'function') ? measureWaitingQueues() : null
                };

                const releasedDelta = end.totalReleased - baseline.totalReleased;
                const effReleasedDelta = end.effTotalLiberados - baseline.effTotalLiberados;
                const avgWaitMs = (end.perfWaits && end.perfWaits.length) ? (end.perfWaits.reduce((a, b) => a + b, 0) / end.perfWaits.length) : null;

                results[mode] = {
                    releasedDelta: Math.max(0, Math.round(releasedDelta || 0)),
                    effReleasedDelta: Math.max(0, Math.round(effReleasedDelta || 0)),
                    cumulativeReleased: end.effTotalLiberados,
                    avgWaitSec: avgWaitMs != null ? Math.round((avgWaitMs / 1000) * 10) / 10 : null,
                    queueEndTotal: end.queueEnd ? Object.values(end.queueEnd).reduce((x, y) => (x || 0) + (y || 0), 0) : null,
                    rawQueueEnd: end.queueEnd
                    ,
                    // debug helpers to diagnose missing Intelligent metrics
                    debug: {
                        perfWaitsCaptured: (end.perfWaits || []).length,
                        perfWaitsTotal: (perfRef.current && perfRef.current[mode] && perfRef.current[mode].waitTimes) ? perfRef.current[mode].waitTimes.length : 0,
                        effTotalLiberadosRaw: (efficiencyStatsRef.current && efficiencyStatsRef.current[mode] && efficiencyStatsRef.current[mode].totalLiberados) ? efficiencyStatsRef.current[mode].totalLiberados.total : 0,
                        exitCount: (exitCountRef.current && exitCountRef.current[mode]) ? exitCountRef.current[mode] : 0,
                        recentExits: (exitLogRef.current && exitLogRef.current.length) ? exitLogRef.current.slice(0, 12) : []
                    }
                };

                // Clear mode progress UI
                try {
                    setTestCurrentMode(null);
                    setTestModeProgress(0);
                } catch (e) { _noop(e); }
                try { setTestInternalStatus(prev => ({ ...(prev || {}), mode: `Modo ${mode} finalizado`, info: 'Esperando siguiente modo o final' })); } catch (e) { _noop(e); }
                // release forced test mode
                try { testForceModeRef.current = null; } catch (e) { _noop(e); }

            } catch (err) {
                results[mode] = { error: String(err) };
            }
        }

        // Restore original speed multiplier (also update ref immediately)
        try { setSpeedMultiplier(prevSpeed); try { speedMultiplierRef.current = prevSpeed; } catch (e) { _noop(e); } } catch (e) { _noop(e); }

        // Compare and recommend
        const classic = results.classic || {};
        const intelligent = results.intelligent || {};
        const score = (r) => ((r.effReleasedDelta || r.releasedDelta || 0) * 2) - ((r.avgWaitSec != null ? r.avgWaitSec : 0) * 1);
        const classicScore = score(classic);
        const intelScore = score(intelligent);
        const winner = classicScore === intelScore ? 'tie' : (classicScore > intelScore ? 'classic' : 'intelligent');

        try { setTestInternalStatus({ warmup: '', mode: '', info: 'Pruebas completadas' }); } catch (e) { _noop(e); }

        // Expose helpers
        try {
            actionsRef.current.pushDebug = pushDebug;
            actionsRef.current.runModeComparisonTests = runModeComparisonTests;
        } catch (e) { _noop(e); }

        return { results, winner, scores: { classic: classicScore, intelligent: intelScore } };
    }
    const [waitingTimeDisplay, setWaitingTimeDisplay] = useState({ N: 0, S: 0, E: 0, W: 0 });
    const [stats, setStats] = useState({
        waiting: { N: 0, S: 0, E: 0, W: 0 },
        active: { N: 0, S: 0, E: 0, W: 0 },
        totalReleased: 0,
        efficiency: 0,
        totals: { N: 0, S: 0, E: 0, W: 0 },
        lastPhase: { N: 0, S: 0, E: 0, W: 0, total: 0 },
        rendered: { total: 0, byType: { car: 0, bus: 0, motorcycle: 0 } },
        metadata: {
            byType: {
                N: { cars: 0, buses: 0, motorcycles: 0 },
                S: { cars: 0, buses: 0, motorcycles: 0 },
                E: { cars: 0, buses: 0, motorcycles: 0 },
                W: { cars: 0, buses: 0, motorcycles: 0 }
            },
            byTrigger: {
                N: { inQueue: 0, released: 0, exitTriggered: 0 },
                S: { inQueue: 0, released: 0, exitTriggered: 0 },
                E: { inQueue: 0, released: 0, exitTriggered: 0 },
                W: { inQueue: 0, released: 0, exitTriggered: 0 }
            }
        }
    });

    // (flow controller removed) — using automatic semaphore logic only

    // Vehicle speed multiplier (slider control). Use ref for animation loop.
    const [speedMultiplier, setSpeedMultiplier] = useState(1.0);
    const speedMultiplierRef = useRef(1.0);
    useEffect(() => { speedMultiplierRef.current = speedMultiplier; }, [speedMultiplier]);

    const currentIntersection = useMemo(() => {
        const city = CITIES_DATA[selectedCity];
        return city?.intersections.find(i => i.id === selectedIntersection) || city?.intersections[0];
    }, [selectedCity, selectedIntersection]);

    // Calcula la intensidad de generación de vehículos basada en la hora
    const currentGenerationIntensity = useMemo(() => {
        const hour = selectedHour;
        const cityPeak = CITIES_DATA[selectedCity]?.peakHours || { morning: [6, 9], evening: [16, 19] };
        const isMorningPeak = hour >= cityPeak.morning[0] && hour <= cityPeak.morning[1];
        const isEveningPeak = hour >= cityPeak.evening[0] && hour <= cityPeak.evening[1];
        const isValley = (hour >= 0 && hour < 6) || (hour > 11 && hour < 14);

        // Determine level based on the intersection's base level and the hour
        const base = currentIntersection?.baseLevel || 'Moderado';
        const level = getTrafficLevelByHour(selectedCity, base, hour);

        // Map human-friendly percentages to levels
        const levelPctMap = { 'Extremo': 100, 'Alto': 80, 'Medio': 65, 'Moderado': 65, 'Bajo': 35, 'Mínimo': 15 };

        if (isMorningPeak || isEveningPeak) {
            return { intensity: 'PICO', level, percentage: levelPctMap[level] ?? 100 };
        } else if (isValley) {
            return { intensity: 'VALLE', level, percentage: levelPctMap[level] ?? 35 };
        } else {
            return { intensity: 'NORMAL', level, percentage: levelPctMap[level] ?? 65 };
        }
    }, [selectedCity, selectedHour]);

    // Normaliza cualquier valor anterior de modo GreenWave al modo inteligente unificado y reinicia el contador de fase
    useEffect(() => {
        if (trafficLightMode === 'greenwave') {
            setTrafficLightMode('intelligent');
            return;
        }
        const now = performance.now();
        // keep the ref updated so the scene's animation functions use latest mode
        trafficModeRef.current = trafficLightMode;
        if (trafficLightMode === 'classic') {
            phaseTimerRef.current = { remaining: 60, lastUpdate: now };
            // Inicializar el estado de transición de fase clásica
            classicPhaseStateRef.current = {
                currentPhase: 'NS',
                phaseState: 'green',
                yellowStartTime: null,
                yellowDuration: 3000
            };
        } else {
            // Modo inteligente/greenwave no usa timer de segundos
            phaseTimerRef.current = { remaining: 0, lastUpdate: now };
        }
    }, [trafficLightMode]);

    useEffect(() => {
        simConfigRef.current.city = selectedCity;
        setConfigChanged(true);
        releasedTotalsRef.current = { N: 0, S: 0, E: 0, W: 0 };
        lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
        const timer = setTimeout(() => setConfigChanged(false), 500);
        const city = CITIES_DATA[selectedCity];
        if (city) {
            const first = city.intersections[0];
            const exists = city.intersections.some(i => i.id === selectedIntersection);
            if (!exists && first) {
                setSelectedIntersection(first.id);
                simConfigRef.current.intersection = first.id;
                // Calcular nivel dinámico para la nueva intersección
                const newLevel = getTrafficLevelByHour(selectedCity, first.baseLevel, selectedHour);
                setDynamicTrafficLevel(newLevel);
            } else if (first) {
                // Calcular nivel dinámico para la intersección actual
                const newLevel = getTrafficLevelByHour(selectedCity, first.baseLevel, selectedHour);
                setDynamicTrafficLevel(newLevel);
            }
        }
        return () => clearTimeout(timer);
    }, [selectedCity, selectedHour, selectedIntersection]);

    // Controla visibilidad de las etiquetas HUD sobre los semáforos
    useEffect(() => {
        Object.values(modeDisplaysRef.current).forEach(display => {
            if (display?.sprite) {
                display.sprite.visible = showSemInfo;
            }
        });
    }, [showSemInfo]);

    useEffect(() => {
        simConfigRef.current.intersection = selectedIntersection;
        setConfigChanged(true);
        releasedTotalsRef.current = { N: 0, S: 0, E: 0, W: 0 };
        lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };

        // Calcular nivel dinámico para la nueva intersección
        if (currentIntersection) {
            const newLevel = getTrafficLevelByHour(
                selectedCity,
                currentIntersection.baseLevel,
                selectedHour
            );
            setDynamicTrafficLevel(newLevel);
        }

        const timer = setTimeout(() => setConfigChanged(false), 500);
        return () => clearTimeout(timer);
    }, [selectedIntersection, selectedCity, selectedHour, currentIntersection]);

    useEffect(() => {
        simConfigRef.current.hour = selectedHour;
        setConfigChanged(true);

        // Calcular y actualizar el nivel de tráfico dinámico
        if (currentIntersection) {
            const newLevel = getTrafficLevelByHour(
                selectedCity,
                currentIntersection.baseLevel,
                selectedHour
            );
            setDynamicTrafficLevel(newLevel);
        }

        const timer = setTimeout(() => setConfigChanged(false), 500);
        return () => clearTimeout(timer);
    }, [selectedHour, currentIntersection, selectedCity]);

    // Dimensiones de diseño
    const LANE_WIDTH = 3.5;         // Ancho de cada carril
    const STREET_LENGTH = 120;      // Longitud de cada calle
    const CROSSING_SIZE = 18;       // Área de cruce central
    const STOP_LINE_BACK = CROSSING_SIZE / 2 + 3; // Distancia de la línea de pare respecto al centro
    const STOP_LINE_PROGRESS = (STREET_LENGTH / 2 - STOP_LINE_BACK) / STREET_LENGTH; // Punto de pare en el recorrido
    const STOP_LINE_WINDOW = 0.035; // Ventana de tolerancia para detenerse
    const QUEUE_TRIGGER_PROGRESS = Math.max(0, STOP_LINE_PROGRESS - 0.05); // Zona de detector previo al semáforo
    const EXIT_TRIGGER_PROGRESS = 0.65; // Marca salida bien avanzando en el carril de salida
    const EXIT_TRIGGER_OFFSET = CROSSING_SIZE / 2 + 14; // posición visual más adelante del cruce
    const VEHICLE_SPAWN_GAP = 8;    // Separación inicial entre vehículos en cola
    const MIN_HEADWAY = 6;          // Distancia mínima entre vehículos en movimiento
    const MIN_HEADWAY_PROGRESS = MIN_HEADWAY / STREET_LENGTH;
    const VEHICLE_SPAWN_BUFFER = 10; // Margen para no spawnear fuera de la vía
    const VEHICLE_SPACING = 5;      // Espacio entre vehículos
    const PHASE_DURATION = 180;     // Ticks por fase
    const MAX_VEHICLES_PER_PHASE = 200; // Aumentado: despachar más vehículos por fase
    const CLASSIC_PHASE_SECONDS = 60; // Duración de fase en modo clásico
    const CLASSIC_YELLOW_SECONDS = 3; // Amortiguador en amarillo antes de cambio
    const LIGHT_INTENSITY_OFF = 0.06;
    const LIGHT_INTENSITY_ON = { red: 1.1, yellow: 0.9, green: 1.0 };

    // Colores
    const WIRE_COLOR = 0x00e9fa;

    const COLORS = {
        // Carriles
        entryLane: 0x3a3a4a,       // Gris oscuro - entrada
        exitLane: 0x6a6a7a,        // Gris medio - salida
        crossing: 0x2a2a3a,        // Muy oscuro - zona cruce
        ground: 0x0f0f1f,          // Negro - suelo
        yellowLine: 0xffc107,      // Amarillo guía

        // Vehículos
        car: 0x2563eb,             // Azul cobalto
        bus: 0xf59e0b,             // Ámbar
        motorcycle: 0xdc2626,      // Rojo vivo

        // Semáforo
        red: 0xff4444,
        yellow: 0xffcc00,
        green: 0x00ff44,
        black: 0x222222
    };

    // Feature toggles
    const ENABLE_TURNS = false; // Desactivar giros (visualmente no deseado)

    const DIRECTION_LABELS = { N: 'NORTE', S: 'SUR', E: 'ESTE', W: 'OESTE' };

    // Función para generar un accidente aleatorio alternando entre ejes vertical y horizontal
    const triggerAccident = () => {
        const axis = Math.random() < 0.5 ? 'vertical' : 'horizontal';
        const directionsByAxis = axis === 'vertical' ? ['N', 'S'] : ['E', 'W'];
        const randomDir = directionsByAxis[Math.floor(Math.random() * directionsByAxis.length)];

        setAccidentLocation(randomDir);
        setAccidentActive(true);
        accidentRef.current = {
            active: true,
            location: randomDir,
            orientation: axis,
            startTick: tickRef.current
        };

        // El accidente durará 10 segundos (se reinicia si se presiona nuevamente)
        setTimeout(() => {
            setAccidentActive(false);
            setAccidentLocation(null);
            accidentRef.current = { active: false, location: null, orientation: null, startTick: 0 };
        }, 10000);
    };

    useEffect(() => {
        if (!mountRef.current) return;

        // Capturar referencias para el cleanup
        const mount = mountRef.current;
        const vehicles = vehiclesRef.current;

        // ===== 1. INICIALIZAR ESCENA =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 100, 200);
        sceneRef.current = scene;

        // Cámara con vista cenital (top-down view)
        const camera = new THREE.PerspectiveCamera(
            45,
            mount.clientWidth / mount.clientHeight,
            0.1,
            500
        );
        camera.position.set(0, 150, 0); // Vista desde arriba
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(mount.clientWidth, mount.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        mount.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 50;
        controls.maxDistance = 200;

        // Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // ===== 2. SUELO =====
        const groundGeometry = new THREE.PlaneGeometry(300, 300);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: COLORS.ground });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        ground.receiveShadow = true;
        scene.add(ground);

        // ===== 3. CREAR 8 CARRILES (4 ENTRADAS + 4 SALIDAS) =====
        // Carril: [ENTRADA-NORTE, SALIDA-NORTE, ENTRADA-SUR, SALIDA-SUR]
        //         [ENTRADA-ESTE, SALIDA-ESTE, ENTRADA-OESTE, SALIDA-OESTE]

        const createLaneGeometry = (label, position, orientation) => {
            const geometry = orientation === 'EW'
                ? new THREE.BoxGeometry(STREET_LENGTH, 0.2, LANE_WIDTH)
                : new THREE.BoxGeometry(LANE_WIDTH, 0.2, STREET_LENGTH);
            const material = new THREE.MeshStandardMaterial({
                color: label.includes('Entry') ? COLORS.entryLane : COLORS.exitLane
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = true;
            mesh.position.set(...position);

            // Añadir wireframe de bordes en color brillante (ligeramente por encima para evitar z-fighting)
            try {
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMat = new THREE.LineBasicMaterial({ color: WIRE_COLOR, transparent: true, opacity: 0.95 });
                const wire = new THREE.LineSegments(edges, lineMat);
                // posicionar el wireframe coincidiendo con la malla pero un poco por encima
                wire.position.set(...position);
                wire.position.y = position[1] + 0.11;
                wire.renderOrder = 999; // intentar forzar que se dibuje encima
                wire.userData = { overlayFor: label };
                scene.add(wire);
            } catch (e) { _noop(e); }

            return { mesh, label };
        };

        const LANE_OFFSET = LANE_WIDTH * 0.5;

        // Distribución para conducción por derecha: el carril de entrada va siempre al lado derecho
        // Carriles NORTE-SUR (verticales en X, longitud sobre eje Z)
        const entryNorthLane = createLaneGeometry('Entry-North', [LANE_OFFSET, 0, 0], 'NS'); // Desde el sur hacia el norte (derecha = +x)
        const exitNorthLane = createLaneGeometry('Exit-North', [-LANE_OFFSET, 0, 0], 'NS');
        const entrySouthLane = createLaneGeometry('Entry-South', [-LANE_OFFSET, 0, 0], 'NS'); // Desde el norte hacia el sur (derecha = -x)
        const exitSouthLane = createLaneGeometry('Exit-South', [LANE_OFFSET, 0, 0], 'NS');

        // Carriles ESTE-OESTE (horizontales en Z, longitud sobre eje X)
        const entryEastLane = createLaneGeometry('Entry-East', [0, 0, LANE_OFFSET], 'EW');   // Desde el oeste hacia el este (derecha = +z)
        const exitEastLane = createLaneGeometry('Exit-East', [0, 0, -LANE_OFFSET], 'EW');
        const entryWestLane = createLaneGeometry('Entry-West', [0, 0, -LANE_OFFSET], 'EW');  // Desde el este hacia el oeste (derecha = -z)
        const exitWestLane = createLaneGeometry('Exit-West', [0, 0, LANE_OFFSET], 'EW');

        [entryNorthLane, exitNorthLane, entrySouthLane, exitSouthLane,
            entryEastLane, exitEastLane, entryWestLane, exitWestLane].forEach(lane => {
                scene.add(lane.mesh);
            });

        // ===== TRIGGERS VISUALES EN ENTRADAS =====
        const createTriggerZone = (dir) => {
            const material = new THREE.MeshStandardMaterial({
                color: 0x00e9fa,
                transparent: true,
                opacity: 0.35,
                emissive: new THREE.Color(0x00e9fa),
                emissiveIntensity: 0.6
            });
            let geometry, position;
            // Trigger vertical (parado) para marcar la detección visualmente
            const height = 3.0;
            const thickness = 0.6;
            const width = LANE_WIDTH * 0.6;

            switch (dir) {
                case 'N': // Entrada desde SUR hacia NORTE (z positiva)
                    geometry = new THREE.BoxGeometry(width, height, thickness);
                    position = new THREE.Vector3(LANE_OFFSET, height / 2, STREET_LENGTH / 2 - thickness);
                    break;
                case 'S': // Entrada desde NORTE hacia SUR (z negativa)
                    geometry = new THREE.BoxGeometry(width, height, thickness);
                    position = new THREE.Vector3(-LANE_OFFSET, height / 2, -STREET_LENGTH / 2 + thickness);
                    break;
                case 'E': // Entrada desde OESTE hacia ESTE (x negativa)
                    geometry = new THREE.BoxGeometry(thickness, height, width);
                    position = new THREE.Vector3(-STREET_LENGTH / 2 + thickness, height / 2, LANE_OFFSET);
                    break;
                case 'W': // Entrada desde ESTE hacia OESTE (x positiva)
                    geometry = new THREE.BoxGeometry(thickness, height, width);
                    position = new THREE.Vector3(STREET_LENGTH / 2 - thickness, height / 2, -LANE_OFFSET);
                    break;
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = false;
            mesh.castShadow = false;
            mesh.position.copy(position);
            mesh.userData = { type: 'triggerZone', direction: dir };
            return mesh;
        };

        // Crea una etiqueta flotante (sprite con canvas) por encima de un trigger
        const createTriggerLabel = (mesh, title, uid) => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                // Draw background
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Title line
                ctx.font = 'bold 18px Inter, sans-serif';
                ctx.fillStyle = '#00e9fa';
                ctx.textAlign = 'center';
                ctx.fillText(title, canvas.width / 2, 20);
                // UID line
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`ID: ${uid}`, canvas.width / 2, 44);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
                material.depthTest = false;
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(8, 2, 1);
                // place above the trigger: mesh.position.y + half-height + offset
                const labelY = (mesh.position.y || 0) + 2.4;
                sprite.position.set(mesh.position.x, labelY, mesh.position.z);
                sprite.userData = { type: 'triggerLabel', triggerRef: mesh, uid };
                scene.add(sprite);
                mesh.userData.labelSprite = sprite;
            } catch (e) { console.warn('createTriggerLabel error', e); }
        };

        ['N', 'S', 'E', 'W'].forEach(dir => {
            // create one trigger per direction by default; code now supports multiple per dir
            const trigger = createTriggerZone(dir);
            triggerZonesRef.current[dir] = trigger; // keep legacy single reference for now
            scene.add(trigger);
            // add a visible label with a short name and unique id for easier debugging/inspection
            try {
                const uid = `${trigger.userData.type}-${dir}-${trigger.uuid.slice(0, 8)}`;
                const title = `Entrada ${dir}`;
                createTriggerLabel(trigger, title, uid);
            } catch (e) { _noop(e); }
        });

        // Calcular y guardar bbox de triggers (usado por la detección por collider)
        // Compute bbox for either single triggers or arrays
        Object.entries(triggerZonesRef.current).forEach(([k, v]) => {
            if (!v) return;
            if (Array.isArray(v)) {
                v.forEach(t => { if (t) { t.updateMatrixWorld(true); t.userData.bbox = new THREE.Box3().setFromObject(t); } });
            } else {
                v.updateMatrixWorld(true);
                v.userData.bbox = new THREE.Box3().setFromObject(v);
            }
        });

        // ===== TRIGGERS VISUALES DE SALIDA EN CADA VÍA =====
        const createExitTriggerZone = (dir) => {
            const material = new THREE.MeshStandardMaterial({
                color: 0xff2ea6,
                transparent: true,
                opacity: 0.35,
                emissive: new THREE.Color(0xff2ea6),
                emissiveIntensity: 0.6
            });
            let geometry, position;
            const height = 3.0;
            const thickness = 0.6;
            const width = LANE_WIDTH * 0.6;

            switch (dir) {
                case 'N': // Vehículos que van al NORTE siguen por x=+LANE_OFFSET; salida más adelante
                    geometry = new THREE.BoxGeometry(width, height, thickness);
                    position = new THREE.Vector3(LANE_OFFSET, height / 2, -EXIT_TRIGGER_OFFSET);
                    break;
                case 'S': // Vehículos que van al SUR siguen por x=-LANE_OFFSET; salida más adelante
                    geometry = new THREE.BoxGeometry(width, height, thickness);
                    position = new THREE.Vector3(-LANE_OFFSET, height / 2, EXIT_TRIGGER_OFFSET);
                    break;
                case 'E': // Vehículos que van al ESTE siguen por z=+LANE_OFFSET; salida más adelante
                    geometry = new THREE.BoxGeometry(thickness, height, width);
                    position = new THREE.Vector3(EXIT_TRIGGER_OFFSET, height / 2, LANE_OFFSET);
                    break;
                case 'W': // Vehículos que van al OESTE siguen por z=-LANE_OFFSET; salida más adelante
                    geometry = new THREE.BoxGeometry(thickness, height, width);
                    position = new THREE.Vector3(-EXIT_TRIGGER_OFFSET, height / 2, -LANE_OFFSET);
                    break;
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = false;
            mesh.castShadow = false;
            mesh.position.copy(position);
            mesh.userData = { type: 'exitTriggerZone', direction: dir };
            return mesh;
        };

        ['N', 'S', 'E', 'W'].forEach(dir => {
            const trigger = createExitTriggerZone(dir);
            exitTriggerZonesRef.current[dir] = trigger;
            scene.add(trigger);
            try {
                const uid = `${trigger.userData.type}-${dir}-${trigger.uuid.slice(0, 8)}`;
                const title = `Salida ${dir}`;
                createTriggerLabel(trigger, title, uid);
            } catch (e) { _noop(e); }
        });

        // Calcular y guardar bbox de exit triggers
        Object.entries(exitTriggerZonesRef.current).forEach(([k, v]) => {
            if (!v) return;
            if (Array.isArray(v)) {
                v.forEach(t => { if (t) { t.updateMatrixWorld(true); t.userData.bbox = new THREE.Box3().setFromObject(t); } });
            } else {
                v.updateMatrixWorld(true);
                v.userData.bbox = new THREE.Box3().setFromObject(v);
            }
        });

        // Debug: create Box3Helper for exit triggers so wireframes match Box3 exactly
        if (debugShowCollidersRef.current) {
            Object.entries(exitTriggerZonesRef.current).forEach(([dir, t]) => {
                try {
                    if (!t || !t.userData?.bbox) return;
                    const helper = new THREE.Box3Helper(t.userData.bbox, 0xff00ff);
                    helper.userData = { debugFor: 'exitTrigger', direction: dir };
                    scene.add(helper);
                    exitDebugMeshesRef.current[dir] = helper;
                } catch (e) { _noop(e); }
            });
        }

        // Etiquetas de calles para diferenciación visual por orientación
        const createStreetLabel = (text, position, rotationY = 0) => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00e9fa';
            ctx.font = '28px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(22, 6, 1);
            sprite.position.set(...position);
            sprite.rotation.y = rotationY;
            return sprite;
        };

        const labels = [
            createStreetLabel('AV. NORTE - SUR', [0, 2.4, STREET_LENGTH / 2 - 8], 0),
            createStreetLabel('AV. NORTE - SUR', [0, 2.4, -STREET_LENGTH / 2 + 8], Math.PI),
            createStreetLabel('AV. ESTE - OESTE', [STREET_LENGTH / 2 - 8, 2.4, 0], -Math.PI / 2),
            createStreetLabel('AV. ESTE - OESTE', [-STREET_LENGTH / 2 + 8, 2.4, 0], Math.PI / 2)
        ];
        labels.forEach(label => scene.add(label));

        // ===== 4. LÍNEAS GUÍA AMARILLAS ORIENTADAS =====
        const createYellowLines = () => {
            // Líneas NS (verticales, de arriba a abajo)
            for (let z = -STREET_LENGTH / 2; z < STREET_LENGTH / 2; z += 4) {
                if (Math.abs(z) > CROSSING_SIZE / 2) {
                    [-LANE_WIDTH / 2, 0, LANE_WIDTH / 2, LANE_WIDTH * 1.75, -LANE_WIDTH * 1.75].forEach(x => {
                        const dashGeom = new THREE.BoxGeometry(0.15, 0.15, 2);
                        const dashMat = new THREE.MeshStandardMaterial({
                            color: COLORS.yellowLine,
                            emissive: COLORS.yellowLine,
                            emissiveIntensity: 0.5
                        });
                        const dash = new THREE.Mesh(dashGeom, dashMat);
                        dash.position.set(x, 0.12, z);
                        scene.add(dash);
                    });
                }
            }

            // Líneas EO (horizontales, de izquierda a derecha)
            for (let x = -STREET_LENGTH / 2; x < STREET_LENGTH / 2; x += 4) {
                if (Math.abs(x) > CROSSING_SIZE / 2) {
                    [-LANE_WIDTH / 2, 0, LANE_WIDTH / 2, LANE_WIDTH * 1.75, -LANE_WIDTH * 1.75].forEach(z => {
                        const dashGeom = new THREE.BoxGeometry(2, 0.15, 0.15);
                        const dashMat = new THREE.MeshStandardMaterial({
                            color: COLORS.yellowLine,
                            emissive: COLORS.yellowLine,
                            emissiveIntensity: 0.5
                        });
                        const dash = new THREE.Mesh(dashGeom, dashMat);
                        dash.position.set(x, 0.12, z);
                        scene.add(dash);
                    });
                }
            }

            // Línea de parada (stopline)
            const stopLinePositions = [
                // Sur -> Norte (entrada por derecha, lane en +x, stopline al sur)
                { x: LANE_OFFSET, z: STOP_LINE_BACK, w: LANE_WIDTH },
                // Norte -> Sur (entrada por derecha, lane en -x, stopline al norte)
                { x: -LANE_OFFSET, z: -STOP_LINE_BACK, w: LANE_WIDTH },
                // Oeste -> Este (entrada por derecha, lane en +z, stopline al oeste)
                { x: STOP_LINE_BACK, z: LANE_OFFSET, w: LANE_WIDTH },
                // Este -> Oeste (entrada por derecha, lane en -z, stopline al este)
                { x: -STOP_LINE_BACK, z: -LANE_OFFSET, w: LANE_WIDTH }
            ];

            stopLinePositions.forEach(pos => {
                const stopGeom = new THREE.BoxGeometry(pos.w, 0.15, 0.4);
                const stopMat = new THREE.MeshStandardMaterial({
                    color: COLORS.yellowLine,
                    emissive: COLORS.yellowLine,
                    emissiveIntensity: 0.8
                });
                const line = new THREE.Mesh(stopGeom, stopMat);
                line.position.set(pos.x, 0.15, pos.z);
                scene.add(line);
            });
            // Debug: print summary of semaphore states and positions to validate mapping
            try {
                const summary = Object.keys(semaphores).reduce((acc, k) => {
                    const s = semaphores[k];
                    const pos = s?.position ? `(${s.position.x.toFixed(1)},${s.position.z.toFixed(1)})` : '(no-pos)';
                    acc[k] = { state: s?.userData?.state, pos };
                    return acc;
                }, {});
                console.debug('[TL] semaphores summary:', summary);
            } catch (e) { }
        };
        createYellowLines();

        // Zona de cruce central
        const crossingGeometry = new THREE.BoxGeometry(CROSSING_SIZE, 0.12, CROSSING_SIZE);
        const crossingMaterial = new THREE.MeshStandardMaterial({
            color: COLORS.crossing,
            emissive: COLORS.crossing,
            emissiveIntensity: 0.1
        });
        const crossing = new THREE.Mesh(crossingGeometry, crossingMaterial);
        crossing.position.y = 0.05;
        scene.add(crossing);

        // ===== 5. CREAR SEMÁFOROS (1 POR CARRIL DE ENTRADA) =====
        const createTrafficLight = (x, z, direction) => {
            const group = new THREE.Group();

            // Poste
            const poleGeo = new THREE.CylinderGeometry(0.12, 0.12, 6);
            const poleMat = new THREE.MeshStandardMaterial({ color: COLORS.black });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 3;
            pole.castShadow = true;
            group.add(pole);

            // Brazo horizontal
            const armGeo = new THREE.BoxGeometry(1, 0.15, 0.15);
            const armMat = new THREE.MeshStandardMaterial({ color: COLORS.black });
            const arm = new THREE.Mesh(armGeo, armMat);
            arm.position.y = 5.5;
            arm.position.z = 0.5;
            group.add(arm);

            // Caja semáforo
            const boxGeo = new THREE.BoxGeometry(0.6, 2, 0.35);
            const boxMat = new THREE.MeshStandardMaterial({ color: COLORS.black });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = 5.5;
            box.position.z = 1;
            box.castShadow = true;
            group.add(box);

            // Luces circulares verticales (R-Y-G)
            const lightGeo = new THREE.CircleGeometry(0.2, 16);

            const redLight = new THREE.Mesh(lightGeo, new THREE.MeshStandardMaterial({
                color: COLORS.red,
                emissive: COLORS.red,
                emissiveIntensity: 0,
                side: THREE.DoubleSide
            }));
            redLight.position.set(0, 6.2, 1.2);
            group.add(redLight);

            const yellowLight = new THREE.Mesh(lightGeo, new THREE.MeshStandardMaterial({
                color: COLORS.yellow,
                emissive: COLORS.yellow,
                emissiveIntensity: 0,
                side: THREE.DoubleSide
            }));
            yellowLight.position.set(0, 5.5, 1.2);
            group.add(yellowLight);

            const greenLight = new THREE.Mesh(lightGeo, new THREE.MeshStandardMaterial({
                color: COLORS.green,
                emissive: COLORS.green,
                emissiveIntensity: 0,
                side: THREE.DoubleSide
            }));
            greenLight.position.set(0, 4.8, 1.2);
            group.add(greenLight);

            group.position.set(x, 0, z);
            group.userData = {
                direction,
                lights: { red: redLight, yellow: yellowLight, green: greenLight },
                state: 'red'
            };

            return group;
        };

        const SEM_OFFSET = LANE_OFFSET + LANE_WIDTH; // Semáforo al costado derecho de cada carril de entrada
        const SEM_APPROACH_OFFSET = STOP_LINE_BACK + 1; // Ubica el poste junto a la línea de pare
        const semaphores = {
            // Cada semáforo queda al lado derecho del carril de entrada y antes de la línea de pare
            N: createTrafficLight(SEM_OFFSET + 0.35, SEM_APPROACH_OFFSET, 'N'),
            S: createTrafficLight(-SEM_OFFSET - 0.35, -SEM_APPROACH_OFFSET, 'S'),
            // Para tráfico que avanza en +x (Oeste→Este), el lado derecho está en -z
            E: createTrafficLight(SEM_APPROACH_OFFSET, -SEM_OFFSET - 0.35, 'E'),
            // Para tráfico que avanza en -x (Este→Oeste), el lado derecho está en +z
            W: createTrafficLight(-SEM_APPROACH_OFFSET, SEM_OFFSET + 0.35, 'W')
        };

        // Orientar semáforos hacia el tráfico entrante (mirando a los vehículos que llegan)
        semaphores.N.rotation.y = 0;                 // Vehículos vienen del sur, semáforo mira al sur (+z)
        semaphores.S.rotation.y = Math.PI;           // Vehículos vienen del norte, semáforo mira al norte (-z)
        semaphores.E.rotation.y = Math.PI / 2;       // Vehículos vienen del oeste, semáforo mira al este (+x)
        semaphores.W.rotation.y = -Math.PI / 2;      // Vehículos vienen del este, semáforo mira al oeste (-x)

        Object.values(semaphores).forEach(sem => scene.add(sem));

        // Flechas de evaluación sobre semáforos (visuales) - ahora 3D + cuadro informativo encima
        const arrowsRef = { N: null, S: null, E: null, W: null };
        const arrowInfoRef = { N: null, S: null, E: null, W: null };

        const createEvaluationArrow = (dir, position) => {
            // Cone pointing downwards toward the semaphore (arrow head pointing to sem)
            const coneGeo = new THREE.ConeGeometry(1.8, 4.0, 20);
            // Use MeshBasicMaterial so it's visible regardless of scene lighting
            const coneMat = new THREE.MeshBasicMaterial({ color: COLORS.black });
            // Make arrow render on top and remain visible in dark scenes
            coneMat.depthTest = false;
            coneMat.depthWrite = false;
            const cone = new THREE.Mesh(coneGeo, coneMat);
            cone.scale.set(1.6, 1.6, 1.6);
            // Position above semaphore
            cone.position.set(position.x, 18.0, position.z);
            // Point downwards
            cone.rotation.x = Math.PI; // point down
            cone.visible = true;
            cone.userData = { type: 'evalArrow3D', direction: dir };
            cone.castShadow = false;
            scene.add(cone);
            arrowsRef[dir] = cone;
            // Set initial arrow color based on semaphore state if available
            try {
                const sem = semaphores?.[dir];
                const state = sem?.userData?.state || 'red';
                if (arrowsRef[dir]) {
                    if (state === 'green') arrowsRef[dir].material.color.setHex(COLORS.green);
                    else if (state === 'yellow') arrowsRef[dir].material.color.setHex(COLORS.yellow);
                    else arrowsRef[dir].material.color.setHex(COLORS.red);
                }
            } catch (e) { }
            try { console.debug('[GreenWave] created arrow', dir, cone.position); } catch (e) { _noop(e); }

            // Create a small UI box above the cone (canvas texture on a sprite)
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 80;
            const ctx = canvas.getContext('2d');
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            // Ensure UI sprite renders above 3D geometry
            material.depthTest = false;
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(9, 3.6, 1);
            sprite.position.set(position.x, 22.0, position.z);
            sprite.visible = false;
            sprite.userData = { type: 'arrowInfo', direction: dir, canvas, ctx, texture };
            scene.add(sprite);
            arrowInfoRef[dir] = sprite;
        };

        // Crear flechas y cuadros para cada semáforo
        createEvaluationArrow('N', semaphores.N.position);
        createEvaluationArrow('S', semaphores.S.position);
        createEvaluationArrow('E', semaphores.E.position);
        createEvaluationArrow('W', semaphores.W.position);

        // Build mapping from logical lane directions to the closest semaphore (in case semaphores were placed differently)
        const buildLaneToSemaphoreMap = () => {
            try {
                const map = {};
                ['N', 'S', 'E', 'W'].forEach(dir => {
                    const trigger = triggerZonesRef.current[dir];
                    if (!trigger) return;
                    let bestKey = null;
                    let bestDist = Infinity;
                    Object.keys(semaphores).forEach(k => {
                        const s = semaphores[k];
                        if (!s) return;
                        const dx = s.position.x - trigger.position.x;
                        const dz = s.position.z - trigger.position.z;
                        const d = Math.sqrt(dx * dx + dz * dz);
                        if (d < bestDist) {
                            bestDist = d;
                            bestKey = k;
                        }
                    });
                    if (bestKey) map[dir] = bestKey;
                });
                laneToSemaphoreMapRef.current = map;
                try { console.debug('[TL] lane->semaphore map', map); } catch (e) { _noop(e); }
            } catch (e) { console.warn('buildLaneToSemaphoreMap error', e); }
        };
        buildLaneToSemaphoreMap();

        // No temporary startup flash — visibility controlled by decision logic

        const setEvaluationArrows = (activeDirs = []) => {
            // Show only a single arrow: the direction that currently has the largest measured queue
            if (!activeDirs) activeDirs = [];

            // If no activeDirs were provided, fall back to currentPhase so an arrow is visible
            if (activeDirs.length === 0) {
                const phase = currentPhaseRef.current;
                if (phase === 'NS') activeDirs = ['N'];
                else if (phase === 'EW') activeDirs = ['E'];
            }

            let chosen = null;
            try { console.debug('[GreenWave] setEvaluationArrows called, activeDirs=', activeDirs, 'phase=', currentPhaseRef.current); } catch (e) { _noop(e); }
            if (activeDirs.length === 1) {
                chosen = activeDirs[0];
            } else {
                try {
                    const counts = measureWaitingQueues();
                    chosen = activeDirs.reduce((best, d) => {
                        if (!best) return d;
                        const bestCount = counts[best] ?? 0;
                        const curCount = counts[d] ?? 0;
                        return curCount > bestCount ? d : best;
                    }, null);
                } catch (err) {
                    // Fallback: pick first
                    chosen = activeDirs[0];
                    console.warn('setEvaluationArrows: failed to measure queues, fallback to first dir', err);
                }
            }

            // Show all arrows but visually emphasize the chosen one
            ['N', 'S', 'E', 'W'].forEach(d => {
                if (arrowsRef[d]) {
                    arrowsRef[d].visible = true;
                    arrowsRef[d].scale.set(d === chosen ? 1.8 : 1.2, d === chosen ? 1.8 : 1.2, d === chosen ? 1.8 : 1.2);
                }
                if (arrowInfoRef[d]) arrowInfoRef[d].visible = (d === chosen);
            });
            try { console.debug('[GreenWave] setEvaluationArrows chosen=', chosen); } catch (e) { _noop(e); }
        };

        // HUD sobre cada semáforo (dirección, temporizador/estado y cola)
        const createModeDisplay = (direction, position) => {
            const canvas = document.createElement('canvas');
            canvas.width = 160;
            canvas.height = 80;
            const ctx = canvas.getContext('2d');
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(10.5, 5.5, 1);
            sprite.position.set(position.x, 8.2, position.z);
            sprite.visible = showSemInfo;
            scene.add(sprite);
            modeDisplaysRef.current[direction] = { sprite, canvas, ctx, texture };
        };

        createModeDisplay('N', semaphores.N.position);
        createModeDisplay('S', semaphores.S.position);
        createModeDisplay('E', semaphores.E.position);
        createModeDisplay('W', semaphores.W.position);

        // Crear contenedor para visualización de accidentes
        const accidentMeshes = { N: null, S: null, E: null, W: null };

        const createAccidentMesh = (direction) => {
            if (accidentMeshes[direction]) {
                scene.remove(accidentMeshes[direction]);
                accidentMeshes[direction].geometry?.dispose();
                accidentMeshes[direction].material?.dispose();
            }

            const isVertical = direction === 'N' || direction === 'S';
            const width = isVertical ? LANE_WIDTH * 0.8 : CROSSING_SIZE * 0.6;
            const depth = isVertical ? CROSSING_SIZE * 0.6 : LANE_WIDTH * 0.8;
            const geo = new THREE.BoxGeometry(width, 1.5, depth);
            const mat = new THREE.MeshStandardMaterial({
                color: 0xff3333,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = 1;

            if (isVertical) {
                mesh.position.x = direction === 'N' ? LANE_OFFSET : -LANE_OFFSET;
                mesh.position.z = 0;
            } else {
                mesh.position.x = 0;
                mesh.position.z = direction === 'E' ? LANE_OFFSET : -LANE_OFFSET;
            }

            scene.add(mesh);
            accidentMeshes[direction] = mesh;
        };

        // ===== 6. CREAR VEHÍCULOS DIFERENCIADOS POR TIPO =====
        const getCurrentRates = () => {
            const { city, intersection, hour } = simConfigRef.current;
            const cityData = CITIES_DATA[city];
            const inter = cityData?.intersections.find(i => i.id === intersection) || cityData?.intersections[0];
            const base = inter?.rates ?? { N: 0.08, S: 0.08, E: 0.08, W: 0.08 };

            let cityFactor = 1.0;
            switch (city) {
                case 'bogota': cityFactor = 1.15; break;
                case 'medellin': cityFactor = 1.1; break;
                case 'cali': cityFactor = 1.05; break;
                case 'barranquilla': cityFactor = 1.0; break;
                case 'cartagena': cityFactor = 0.95; break;
                default: cityFactor = 1.0;
            }

            const isMorningPeak = hour >= 6 && hour <= 9;
            const isEveningPeak = hour >= 16 && hour <= 19;
            let dirFactors = { N: 1, S: 1, E: 1, W: 1 };
            if (isMorningPeak) {
                dirFactors = { N: 0.9, S: 2.1, E: 1.9, W: 1.4 };
            } else if (isEveningPeak) {
                dirFactors = { N: 2.0, S: 1.0, E: 1.3, W: 1.9 };
            }

            return {
                N: base.N * cityFactor * dirFactors.N,
                S: base.S * cityFactor * dirFactors.S,
                E: base.E * cityFactor * dirFactors.E,
                W: base.W * cityFactor * dirFactors.W
            };
        };

        const pickDirection = (rates) => {
            const total = rates.N + rates.S + rates.E + rates.W;
            if (total <= 0) return ['N', 'S', 'E', 'W'][Math.floor(Math.random() * 4)];
            let r = Math.random() * total;
            if ((r -= rates.N) <= 0) return 'N';
            if ((r -= rates.S) <= 0) return 'S';
            if ((r -= rates.E) <= 0) return 'E';
            return 'W';
        };

        const createVehicle = (type, direction, offsetOverride = null) => {
            let geo, color;

            switch (type) {
                case 'bus':
                    geo = new THREE.BoxGeometry(2.2, 2.5, 4.8);
                    color = COLORS.bus;
                    break;
                case 'motorcycle':
                    geo = new THREE.BoxGeometry(0.7, 1.1, 1.6);
                    color = COLORS.motorcycle;
                    break;
                default: // car
                    geo = new THREE.BoxGeometry(1.6, 1.4, 3.2);
                    color = COLORS.car;
            }

            const mat = new THREE.MeshStandardMaterial({ color });
            const vehicle = new THREE.Mesh(geo, mat);
            vehicle.castShadow = true;
            vehicle.receiveShadow = true;

            // Posicionamiento inicial según dirección
            const spacing = VEHICLE_SPAWN_GAP;
            const queueCount = vehiclesRef.current[direction].length;
            const offset = offsetOverride ?? (queueCount * spacing);

            switch (direction) {
                case 'N': // Entra desde sur (carril derecho: +x)
                    vehicle.position.set(LANE_OFFSET, 1, STREET_LENGTH / 2 - offset);
                    vehicle.rotation.y = 0;
                    break;
                case 'S': // Entra desde norte (carril derecho: -x)
                    vehicle.position.set(-LANE_OFFSET, 1, -STREET_LENGTH / 2 + offset);
                    vehicle.rotation.y = Math.PI;
                    break;
                case 'E': // Entra desde oeste (carril derecho: +z)
                    vehicle.position.set(-STREET_LENGTH / 2 + offset, 1, LANE_OFFSET);
                    vehicle.rotation.y = Math.PI / 2;
                    break;
                case 'W': // Entra desde este (carril derecho: -z)
                    vehicle.position.set(STREET_LENGTH / 2 - offset, 1, -LANE_OFFSET);
                    vehicle.rotation.y = -Math.PI / 2;
                    break;
            }

            const colliderSize = new THREE.Vector3(geo.parameters.width, geo.parameters.height, geo.parameters.depth);

            vehicle.userData = {
                type,
                direction,
                progress: 0,
                // store baseSpeed so a global multiplier can be applied without changing logic
                baseSpeed: 0.007 + Math.random() * 0.003,
                // decide up-front if this vehicle may take a random right turn (disabled globally)
                turnPossible: false,
                turning: false,
                turnData: null,
                inEntryLane: true,
                released: false,
                queueTriggered: false,
                exitTriggered: false,
                countedExit: false,
                collider: new THREE.Box3(),
                colliderSize
            };

            // Debug: add a Box3Helper attached to the vehicle's collider so it updates automatically
            try {
                if (debugShowCollidersRef.current) {
                    const dbgHelper = new THREE.Box3Helper(vehicle.userData.collider, 0x00ff00);
                    dbgHelper.userData = { debugFor: 'vehicleCollider' };
                    scene.add(dbgHelper);
                    vehicle.userData.debugHelper = dbgHelper;
                }
            } catch (e) { _noop(e); }

            scene.add(vehicle);
            return vehicle;
        };

        const spawnVehicle = (direction) => {
            const types = ['car', 'car', 'car', 'motorcycle', 'bus'];
            const type = types[Math.floor(Math.random() * types.length)];
            const dirVehicles = vehiclesRef.current[direction];
            const queueCount = dirVehicles.length;
            const offset = queueCount * VEHICLE_SPAWN_GAP;

            // Evita spawnear si ya no cabe en el tramo visible
            if (offset > STREET_LENGTH - VEHICLE_SPAWN_BUFFER) return;

            const vehicle = createVehicle(type, direction, offset);
            // Asignar ID único y generación inicial
            vehicle.userData.id = Math.random().toString(36).substr(2, 9);
            vehicle.userData.phaseGeneration = phaseGenerationRef.current;
            dirVehicles.push(vehicle);
        };
        // spawnVehicle available locally

        // ===== 7. ACTUALIZAR SEMÁFOROS =====
        const updateTrafficLights = (activeDirections, state = 'green') => {
            try { console.debug('[TL] updateTrafficLights called activeDirections=', activeDirections, 'state=', state); } catch (e) { }
            // Map logical directions to physical semaphore keys using the precomputed nearest map
            const laneMap = laneToSemaphoreMapRef.current || {};
            const physicalActive = (activeDirections || []).map(d => laneMap[d] || d);
            try { console.debug('[TL] physicalActive mapped=', physicalActive, 'laneMap=', laneMap); } catch (e) { }
            ['N', 'S', 'E', 'W'].forEach(dir => {
                const sem = semaphores[dir];
                const lights = sem.userData.lights;
                const isActive = physicalActive.includes(dir);

                // Default: render all lamp faces as "off" (black)
                try {
                    lights.red.material.color.setHex(COLORS.black);
                    lights.yellow.material.color.setHex(COLORS.black);
                    lights.green.material.color.setHex(COLORS.black);
                    lights.red.material.emissiveIntensity = 0;
                    lights.yellow.material.emissiveIntensity = 0;
                    lights.green.material.emissiveIntensity = 0;
                } catch (err) {
                    // ignore if materials already disposed
                }

                if (isActive) {
                    if (state === 'yellow') {
                        try { lights.yellow.material.color.setHex(COLORS.yellow); } catch (e) { _noop(e); }
                        try { lights.yellow.material.emissiveIntensity = LIGHT_INTENSITY_ON.yellow; } catch (e) { _noop(e); }
                        sem.userData.state = 'yellow';
                        try { if (arrowsRef[dir]) arrowsRef[dir].material.color.setHex(COLORS.yellow); } catch (e) { _noop(e); }

                        // Registrar el inicio de la fase amarilla para transición de velocidad
                        try {
                            const prevState = prevSemStateRef.current[dir];
                            if (prevState === 'green') {
                                // Transición de verde a amarillo: preparar desaceleración
                                yellowTransitionRef.current[dir].isYellow = true;
                                yellowTransitionRef.current[dir].yellowStartTime = performance.now();
                                yellowTransitionRef.current[dir].transitionType = 'decelerate'; // verde -> amarillo -> rojo
                            } else if (prevState === 'red') {
                                // Transición de rojo a amarillo: preparar aceleración
                                yellowTransitionRef.current[dir].isYellow = true;
                                yellowTransitionRef.current[dir].yellowStartTime = performance.now();
                                yellowTransitionRef.current[dir].transitionType = 'accelerate'; // rojo -> amarillo -> verde
                            }
                        } catch (e) { _noop(e); }
                    } else {
                        try { lights.green.material.color.setHex(COLORS.green); } catch (e) { _noop(e); }
                        try { lights.green.material.emissiveIntensity = LIGHT_INTENSITY_ON.green; } catch (e) { _noop(e); }
                        sem.userData.state = 'green';

                        // Limpiar la bandera de transición amarilla cuando se pasa a verde
                        try {
                            yellowTransitionRef.current[dir].isYellow = false;
                            yellowTransitionRef.current[dir].transitionType = null;
                        } catch (e) { _noop(e); }

                        // If this semaphore was red previously, compute red->green interval
                        try {
                            const lastRed = sem.userData.lastRedAt;
                            const now = performance.now();
                            if (lastRed && typeof lastRed === 'number') {
                                const delta = Math.max(0, now - lastRed);
                                const curMode = (trafficModeRef && trafficModeRef.current) ? trafficModeRef.current : (trafficLightMode || 'classic');
                                const modeKey = (curMode === 'greenwave' || curMode === 'intelligent') ? 'intelligent' : 'classic';
                                if (!redToGreenStatsRef.current[modeKey]) {
                                    redToGreenStatsRef.current[modeKey] = { count: 0, totalMs: 0, sumSq: 0 };
                                }
                                const s = redToGreenStatsRef.current[modeKey];
                                s.count = (s.count || 0) + 1;
                                s.totalMs = (s.totalMs || 0) + delta;
                                s.sumSq = (s.sumSq || 0) + (delta * delta);
                                try { pushDebug && pushDebug(`[RTG] ${modeKey} ${dir} ms=${Math.round(delta)}`); } catch (e) { _noop(e); }
                            }
                        } catch (e) { _noop(e); }
                        try { if (arrowsRef[dir]) arrowsRef[dir].material.color.setHex(COLORS.green); } catch (e) { _noop(e); }
                    }
                } else {
                    // Non-active (red) -> illuminate the red lamp so it's visibly red
                    try { lights.red.material.color.setHex(COLORS.red); } catch (e) { _noop(e); }
                    try { lights.red.material.emissiveIntensity = LIGHT_INTENSITY_ON.red; } catch (e) { _noop(e); }
                    sem.userData.state = 'red';
                    try { sem.userData.lastRedAt = performance.now(); } catch (e) { _noop(e); }
                    try { if (arrowsRef[dir]) arrowsRef[dir].material.color.setHex(COLORS.red); } catch (e) { _noop(e); }

                    // Limpiar la bandera de transición amarilla cuando se pasa a rojo
                    try {
                        yellowTransitionRef.current[dir].isYellow = false;
                        yellowTransitionRef.current[dir].transitionType = null;
                    } catch (e) { _noop(e); }

                    // Track green windows for performance measurement (run after state assignment)
                    try {
                        const now = performance.now();
                        const prev = prevSemStateRef.current[dir] || 'red';
                        const curr = sem.userData.state;
                        if (prev !== 'green' && curr === 'green') {
                            // green started
                            greenActiveInfoRef.current[dir] = { start: now, hadVehicle: false };
                        } else if (prev === 'green' && curr !== 'green') {
                            // green ended
                            const g = greenActiveInfoRef.current[dir];
                            if (g && typeof g.start === 'number') {
                                const dur = Math.max(0, now - g.start);
                                const modeKey = getEffectiveMode();
                                if (modeKey && perfRef.current[modeKey]) {
                                    if (g.hadVehicle) perfRef.current[modeKey].greenOpenWithVehicles += dur;
                                    else perfRef.current[modeKey].greenOpenWasted += dur;
                                }
                            }
                            greenActiveInfoRef.current[dir] = null;
                        }
                        prevSemStateRef.current[dir] = curr;
                    } catch (e) { _noop(e); }

                    // Safety: ensure vehicles still waiting at the stop line for this semaphore are not marked as released
                    try {
                        const laneMap = laneToSemaphoreMapRef.current || {};
                        let cleared = 0;
                        // For each logical lane, if it's mapped to this physical semaphore key, clear its released flags
                        ['N', 'S', 'E', 'W'].forEach(lane => {
                            const mapped = laneMap[lane] || lane;
                            if (mapped !== dir) return;
                            const dirVehicles = vehiclesRef.current?.[lane] || [];
                            dirVehicles.forEach(v => {
                                if (v?.userData && v.userData.inEntryLane && !v.userData.exitTriggered) {
                                    if (v.userData.released) {
                                        v.userData.released = false;
                                        cleared++;
                                    }
                                }
                            });
                        });
                        try { if (cleared > 0) console.debug(`[TL] cleared released flags for ${cleared} vehicles on semaphore ${dir}`); } catch (e) { _noop(e); }
                    } catch (e) {
                        // ignore
                    }
                }
            });
            // Record last chosen directions for HUD transparency
            try {
                lastChosenDirsRef.current = Array.isArray(activeDirections) ? activeDirections.slice() : [];
            } catch (e) { _noop(e); lastChosenDirsRef.current = []; }
        };

        // ===== 7.1 HUD DE MODO SOBRE SEMÁFOROS =====
        const renderModeDisplays = (waitingCounts) => {
            if (!showSemInfo) return;
            const isClassic = trafficModeRef.current === 'classic';
            const timer = phaseTimerRef.current;

            // GARANTIZAR que solo en modo clásico se muestre el timer
            if (!isClassic) {
                timer.remaining = 0;
            }

            // const activeAxis = currentPhaseRef.current;

            ['N', 'S', 'E', 'W'].forEach(dir => {
                const display = modeDisplaysRef.current[dir];
                if (!display) return;

                const ctx = display.ctx;
                const { width: w, height: h } = display.canvas;
                ctx.clearRect(0, 0, w, h);

                // Fondo
                ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
                ctx.fillRect(0, 0, w, h);

                // Encabezado: dirección
                ctx.fillStyle = '#00e9fa';
                ctx.font = 'bold 16px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(DIRECTION_LABELS[dir], w / 2, 16);

                // Estado / modo
                const semState = semaphores[dir].userData.state;
                ctx.font = '13px Inter, sans-serif';
                if (isClassic) {
                    ctx.fillStyle = '#fcd34d';
                    ctx.fillText(`Contando: ${Math.ceil(timer.remaining)}s`, w / 2, 34);
                } else {
                    ctx.fillStyle = '#34d399';
                    // Use last measured counts for display to ensure HUD reflects trigger/collider data
                    const measured = lastMeasuredCountsRef.current || waitingCounts;
                    const _totalQueued = measured.N + measured.S + measured.E + measured.W;
                    const dynamicThreshold = calculateDynamicThreshold(measured, selectedHour);
                    const factor = getAdjustmentFactorByHour(selectedHour);
                    const estimateMarker = lastMeasurementEstimatedRef.current ? ' (estimado)' : '';
                    ctx.fillText(`GreenWave™ | Umbral: ${dynamicThreshold} | Factor: ${factor.toFixed(1)}x${estimateMarker}`, w / 2, 34);
                }

                // Cola de vehículos
                ctx.fillStyle = '#9ca3af';
                // Validate consistency: prefer lastMeasuredCountsRef; if mismatch, correct and log
                const displayCounts = lastMeasuredCountsRef.current || waitingCounts;
                let disp = displayCounts[dir] ?? 0;
                if (!Number.isFinite(disp) || disp < 0) {
                    pushDebug(`HUD correction: invalid count for ${dir} -> ${disp}; fixing to 0`);
                    disp = 0;
                }
                const estimatedSuffix = lastMeasurementEstimatedRef.current ? ' (estimado)' : '';
                ctx.fillText(`Cola: ${disp}${estimatedSuffix}`, w / 2, 52);

                // Liberados por dirección (obtenidos de triggers de salida)
                try {
                    const releasedRaw = (releasedTotalsRef.current && releasedTotalsRef.current[dir]) || 0;
                    const released = Math.max(0, Math.floor(releasedRaw));
                    const exitTriggerExists = !!(exitTriggerZonesRef.current && exitTriggerZonesRef.current[dir] && exitTriggerZonesRef.current[dir].userData && exitTriggerZonesRef.current[dir].userData.bbox);
                    const relEst = !exitTriggerExists ? ' (estimado)' : '';
                    ctx.font = '11px Inter, sans-serif';
                    ctx.fillStyle = '#c7f9e7';
                    ctx.fillText(`Liberados: ${released}${relEst}`, w / 2, 62);
                    ctx.font = '13px Inter, sans-serif';
                } catch (e) { _noop(e); }

                // Estado del semáforo
                ctx.fillStyle = semState === 'green' ? '#22c55e' : '#ef4444';
                ctx.fillText(semState === 'green' ? 'Verde' : 'Rojo', w / 2, 68);

                // Show last prioritized direction for transparency
                try {
                    const lp = lastPriorityAxisRef.current || 'N/A';
                    ctx.font = '10px Inter, sans-serif';
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillText(`Últ. prioridad eje: ${lp}`, w / 2, 78);
                } catch (e) { _noop(e); }

                display.texture.needsUpdate = true;
            });
        };

        // Render the arrow info boxes above each arrow (timer in classic, queued vehicles in GreenWave)
        const renderArrowInfo = (waitingCounts) => {
            ['N', 'S', 'E', 'W'].forEach(dir => {
                const info = arrowInfoRef[dir];
                if (!info) return;
                const { canvas, ctx, texture } = info.userData;
                const { width: w, height: h } = canvas;
                ctx.clearRect(0, 0, w, h);

                // Background
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.fillRect(0, 0, w, h);

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#00e9fa';
                ctx.font = 'bold 14px Inter, sans-serif';
                ctx.fillText(DIRECTION_LABELS[dir], w / 2, 12);
                // Mostrar nombre/código del semáforo para identificar el dispositivo exacto
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`Semáforo: ${dir} / ${DIRECTION_LABELS[dir]}`, w / 2, 28);

                const isClassic = trafficModeRef.current === 'classic';
                if (isClassic) {
                    const timer = phaseTimerRef.current;
                    const remaining = Math.max(0, Math.ceil(timer.remaining ?? CLASSIC_PHASE_SECONDS));
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '13px Inter, sans-serif';
                    ctx.fillText(`Timer: ${remaining}s`, w / 2, 46);
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '12px Inter, sans-serif';
                    ctx.fillText(`Modo: Clásico`, w / 2, 64);
                } else {
                    // GreenWave / Intelligent: show vehicles currently queued for this direction
                    // Use the current measured counts passed as parameter (most up-to-date)
                    const queued = waitingCounts[dir] ?? 0;
                    const est = '';
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '13px Inter, sans-serif';
                    ctx.fillText(`En cola: ${queued}${est}`, w / 2, 46);

                    // Make arrow visibility correspond to semaphore state (green shows arrow active)
                    try {
                        const semState = semaphores[dir].userData.state;
                        const arrow = arrowsRef[dir];
                        if (arrow) {
                            arrow.visible = semState === 'green';
                        }
                    } catch (e) { }
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '12px Inter, sans-serif';
                    ctx.fillText(`Modo: GreenWave`, w / 2, 64);
                }

                texture.needsUpdate = true;
            });
        };

        // Medir colas usando el trigger bbox si está disponible (más preciso),
        // de lo contrario caer al método por flags (queueTriggered)
        const measureWaitingQueues = () => {
            const counts = { N: 0, S: 0, E: 0, W: 0 };

            ['N', 'S', 'E', 'W'].forEach(dir => {
                try {
                    const trigger = triggerZonesRef.current?.[dir];
                    // If trigger bbox exists, use collider intersection (most accurate)
                    if (trigger && trigger.userData && trigger.userData.bbox) {
                        counts[dir] = countQueuedInDir(dir);
                    } else {
                        // Fallback: use flags set when vehicles passed the logical entry trigger
                        const arr = vehiclesRef.current[dir] || [];
                        counts[dir] = arr.filter(v => v.userData.queueTriggered && !v.userData.exitTriggered && !v.userData.released).length;
                    }
                } catch (e) {
                    // on error, fallback to safer flag method
                    try {
                        const arr = vehiclesRef.current[dir] || [];
                        counts[dir] = arr.filter(v => v.userData.queueTriggered && !v.userData.exitTriggered && !v.userData.released).length;
                    } catch (e2) { counts[dir] = 0; }
                }
            });

            // Sanitize counts to prevent negatives or NaN
            ['N', 'S', 'E', 'W'].forEach(k => {
                if (!Number.isFinite(counts[k]) || counts[k] < 0) counts[k] = 0;
                counts[k] = Math.floor(counts[k]);
            });

            // Save last measured counts for HUD consistency
            lastMeasuredCountsRef.current = { ...counts };
            lastMeasurementValidRef.current = true;
            lastMeasurementEstimatedRef.current = false;

            // Do NOT overwrite accumulators here. Keep lastMeasuredCountsRef as the live snapshot
            // Accumulation into `efficiencyStatsRef.current[mode].totalEnCola` happens only at end-of-cycle snapshots.

            return counts;
        };

        // Contar vehículos en cola para una dirección usando collision bbox del trigger
        const countQueuedInDir = (dir) => {
            try {
                const triggers = getEntryTriggersForDir(dir);
                if (!triggers || triggers.length === 0) {
                    // fallback to flags
                    return vehiclesRef.current[dir].filter(v => v.userData.queueTriggered && v.userData.inEntryLane && !v.userData.released).length;
                }
                // Sum vehicles intersecting any of the triggers for this dir
                const arr = vehiclesRef.current[dir] || [];
                let n = 0;
                arr.forEach(v => {
                    if (v.userData.released) return;
                    if (!v.userData.collider) {
                        if (v.userData.queueTriggered && v.userData.inEntryLane) n++;
                        return;
                    }
                    for (const t of triggers) {
                        try {
                            const tbbox = t?.userData?.bbox;
                            if (tbbox && v.userData.collider.intersectsBox(tbbox) && v.userData.inEntryLane) {
                                n++;
                                break; // count once even if multiple triggers intersect
                            }
                        } catch (e) { }
                    }
                });
                return n;
            } catch (e) {
                try { return vehiclesRef.current[dir].filter(v => v.userData.queueTriggered && v.userData.inEntryLane && !v.userData.released).length; } catch (e2) { return 0; }
            }
        };





        // Calcula la matriz principal (promedio móvil) de colas por carril
        const computeMainMatrixAvg = () => {
            const hist = waitingHistoryRef.current || [];
            if (hist.length === 0) return null;
            const sum = hist.reduce((acc, h) => {
                acc.N += h.N; acc.S += h.S; acc.E += h.E; acc.W += h.W; return acc;
            }, { N: 0, S: 0, E: 0, W: 0 });
            const len = hist.length;
            return { N: sum.N / len, S: sum.S / len, E: sum.E / len, W: sum.W / len };
        };

        // Decisión por carril comparando con la matriz principal
        // Devuelve { targetAxis, greenDirections, reason }
        const decideByLane = (waitingCounts) => {
            const laneCounts = { ...waitingCounts };

            // ===== RESPETO A LA REGLA DE EMPTY LANES =====
            // Incluso si hay historial, NO ignorar carriles completamente vacíos
            const { N, S, E, W } = laneCounts;
            const nsTotal = N + S;
            const ewTotal = E + W;
            const counts = [{ d: 'N', c: N }, { d: 'S', c: S }, { d: 'E', c: E }, { d: 'W', c: W }];
            const hasEmpty = counts.some(x => x.c === 0);
            const nonEmpty = counts.filter(x => x.c > 0);

            if (hasEmpty && nonEmpty.length > 0 && nonEmpty.length < 4) {
                // Al menos 1 carril está vacío, respetar la prioridad de empty lanes
                let targetAxis = null;
                if (nsTotal === 0 && ewTotal > 0) {
                    targetAxis = 'EW';
                } else if (ewTotal === 0 && nsTotal > 0) {
                    targetAxis = 'NS';
                } else {
                    targetAxis = nsTotal >= ewTotal ? 'NS' : 'EW';
                }
                // AMBOS semáforos del eje deben estar verdes (sin filtrar)
                const greenDirections = targetAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];
                return { useFallback: false, targetAxis, greenDirections, reason: 'empty_lane_priority_in_decideByLane', respetingEmptyLanes: true };
            }

            const mainAvg = computeMainMatrixAvg();

            // Si no hay historial suficiente, no usar esta lógica
            if (!mainAvg) {
                return { useFallback: true };
            }

            // PRIORIDAD POR TIEMPO DE ESPERA: si alguna dirección ha esperado más que el umbral,
            // darle prioridad inmediatamente para evitar olvido (justice temporal).
            try {
                const waitTimes = waitingTimeByDirectionRef.current || { N: 0, S: 0, E: 0, W: 0 };
                const candidates = Object.keys(waitTimes).filter(d => waitTimes[d] > WAITING_TIME_THRESHOLD);
                if (candidates.length > 0) {
                    candidates.sort((a, b) => waitTimes[b] - waitTimes[a]);
                    const chosenDir = candidates[0];
                    const targetAxis = (chosenDir === 'N' || chosenDir === 'S') ? 'NS' : 'EW';
                    const greenDirections = targetAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];
                    // Ensure chosenDir is included even if its count is low
                    if (!greenDirections.includes(chosenDir)) greenDirections.splice(0, 0, chosenDir);
                    return { useFallback: false, targetAxis, greenDirections, reason: 'waiting_time_priority', chosenDir, waitTimes };
                }
            } catch (err) {
                console.warn('waiting-time priority check error', err);
            }

            // Construir array por carril y diferencias respecto a la matriz principal
            const diffs = {
                N: laneCounts.N - Math.round(mainAvg.N),
                S: laneCounts.S - Math.round(mainAvg.S),
                E: laneCounts.E - Math.round(mainAvg.E),
                W: laneCounts.W - Math.round(mainAvg.W)
            };

            // Umbral dinámico para considerar una diferencia relevante
            // Basado en el histórico: si los promedios son pequeños, requerir diferencia absoluta mayor
            const historicalMax = Math.max(1, Math.round(Math.max(mainAvg.N, mainAvg.S, mainAvg.E, mainAvg.W)));
            const MIN_DIFF = Math.max(2, Math.round(historicalMax * 0.5));

            const overloaded = Object.keys(diffs).filter(k => diffs[k] >= MIN_DIFF);

            // Sumar por eje
            const nsSum = laneCounts.N + laneCounts.S;
            const ewSum = laneCounts.E + laneCounts.W;

            // Si hay carriles sobrecargados, priorizar por suma de sobrecarga (no solo por conteo de carriles)
            if (overloaded.length > 0) {
                const nsOverSum = overloaded.reduce((s, k) => s + ((k === 'N' || k === 'S') ? diffs[k] : 0), 0);
                const ewOverSum = overloaded.reduce((s, k) => s + ((k === 'E' || k === 'W') ? diffs[k] : 0), 0);

                // Requerir que la suma de sobrecarga sea significativa
                if (Math.max(nsOverSum, ewOverSum) >= MIN_DIFF) {
                    const targetAxis = nsOverSum >= ewOverSum ? 'NS' : 'EW';
                    const greenDirections = [];
                    if (targetAxis === 'NS') {
                        if (laneCounts.N > 0) greenDirections.push('N');
                        if (laneCounts.S > 0) greenDirections.push('S');
                    } else {
                        if (laneCounts.E > 0) greenDirections.push('E');
                        if (laneCounts.W > 0) greenDirections.push('W');
                    }
                    return { useFallback: false, targetAxis, greenDirections, reason: 'overloaded_lanes', overloaded, diffs, mainAvg };
                }
            }

            // Si no hay carriles claramente sobrecargados, comparar totales por eje
            // Requerir una diferencia mínima relativa para cambiar el eje
            const totalQueued = nsSum + ewSum;
            const dynamicThresh = Math.max(2, Math.round(totalQueued * 0.25));
            if (Math.abs(nsSum - ewSum) < dynamicThresh) {
                // No hay diferencia suficiente: fallback para usar la lógica global
                return { useFallback: true };
            }

            const targetAxis = nsSum > ewSum ? 'NS' : 'EW';
            // AMBOS semáforos del eje deben estar verdes (sin filtrar)
            const greenDirections = targetAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];
            return { useFallback: false, targetAxis, greenDirections, reason: 'axis_balance', diffs, mainAvg };
        };

        // Reinicia el estado de los vehículos al entrar a GreenWave
        const resetVehiclesStateForGreenWave = () => {
            try {
                // Limpiar historial de colas
                waitingHistoryRef.current = [];

                ['N', 'S', 'E', 'W'].forEach(dir => {
                    vehiclesRef.current[dir].forEach(v => {
                        // Reset flags
                        v.userData.released = false;
                        v.userData.queueTriggered = false;
                        v.userData.exitTriggered = false;
                        v.userData.countedExit = false;
                        v.userData.ignoreExitUntil = null;

                        // Cancel any in-progress turn so vehicles don't remain mid-arc
                        v.userData.turning = false;
                        v.userData.turnData = null;

                        // Reset progress and position to spawn location so they leave trigger zones
                        v.userData.progress = 0;
                        v.userData.inEntryLane = true;

                        // Reposicionar según dirección (mismo comportamiento que createVehicle)
                        if (v.userData.direction === 'N') {
                            v.position.set(LANE_OFFSET, 1, STREET_LENGTH / 2 - 0);
                            v.rotation.y = 0;
                        } else if (v.userData.direction === 'S') {
                            v.position.set(-LANE_OFFSET, 1, -STREET_LENGTH / 2 + 0);
                            v.rotation.y = Math.PI;
                        } else if (v.userData.direction === 'E') {
                            v.position.set(-STREET_LENGTH / 2 + 0, 1, LANE_OFFSET);
                            v.rotation.y = Math.PI / 2;
                        } else if (v.userData.direction === 'W') {
                            v.position.set(STREET_LENGTH / 2 - 0, 1, -LANE_OFFSET);
                            v.rotation.y = -Math.PI / 2;
                        }

                        // Actualizar collider inmediatamente (usar setFromObject para respetar rotación/orientación)
                        if (v.userData.collider) {
                            try {
                                v.userData.collider.setFromObject(v);
                            } catch (e) {
                                // fallback
                                v.userData.collider.setFromCenterAndSize(v.position, v.userData.colliderSize);
                            }
                        }
                    });
                });

                // Reset de contadores de fase (no reiniciar los acumuladores globales usados por el panel)
                lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                releasedTotalsRef.current = { N: 0, S: 0, E: 0, W: 0 };
                // NOTE: do NOT reset statsRef.current.totalReleased here — keeping the global totalReleased
                // preserves cumulative counts used by GreenWave snapshots and prevents unintended resets
            } catch (err) {
                console.warn('resetVehiclesStateForGreenWave error', err);
            }
        };

        // Expose reset helper to JSX
        try {
            actionsRef.current.resetVehicles = resetVehiclesStateForGreenWave;
        } catch (e) { }

        // ===== GREENWAVE™ DYNAMIC THRESHOLD SYSTEM =====
        // Calcula el factor de ajuste según la hora del día (0.8 - 1.2)
        const getAdjustmentFactorByHour = (hour) => {
            const { morning, evening } = CITIES_DATA[simConfigRef.current.city]?.peakHours || { morning: [6, 9], evening: [16, 19] };

            const isMorningPeak = hour >= morning[0] && hour <= morning[1];
            const isEveningPeak = hour >= evening[0] && hour <= evening[1];
            const isValley = (hour >= 0 && hour < 6) || (hour > 11 && hour < 14);

            // En hora pico: factor alto (1.2) → umbral más alto
            // En hora normal: factor medio (1.0)
            // En hora valle: factor bajo (0.8) → umbral más bajo
            if (isMorningPeak || isEveningPeak) return 1.2;
            if (isValley) return 0.8;
            return 1.0;
        };

        // Calcula el umbral dinámico basado en el tráfico total
        const calculateDynamicThreshold = (waitingCounts, hour) => {
            const total = waitingCounts.N + waitingCounts.S + waitingCounts.E + waitingCounts.W;
            const factor = getAdjustmentFactorByHour(hour);

            // Fórmula: Umbral = round( (totalVehículos / 4) * factor )
            const threshold = Math.round((total / 4) * factor);

            // Mínimo de 1 vehículo, máximo de 12
            return Math.max(1, Math.min(12, threshold));
        };

        // Aplica lógica GreenWave™ con umbral dinámico
        // ===== LÓGICA GREENWAVE™ CON UMBRAL DINÁMICO =====
        // Fórmula: U = (T/4) * k
        // Prioridad: SIEMPRE a la dirección con MÁS vehículos
        const applyGreenWaveDynamicLogic = (waitingCounts) => {
            const { N, S, E, W } = waitingCounts;
            // helper para finalizar una decisión: actualizar semáforos, contar tiempos de espera y actualizar HUD
            const finalizeChoice = (greenDirs, axis, reason) => {
                try { setEvaluationArrows(greenDirs); } catch (err) { _noop(err); }

                // EN MODO INTELIGENTE: Comenzar con AMARILLO en lugar de verde directo
                // Esto permite que los vehículos aceleren gradualmente antes de pasar
                const isIntelligentMode = effectiveMode !== 'classic';
                if (isIntelligentMode) {
                    // Iniciar transición amarilla
                    intelligentYellowStateRef.current.isTransitioning = true;
                    intelligentYellowStateRef.current.nextPhase = axis;
                    intelligentYellowStateRef.current.nextGreenDirs = greenDirs;
                    intelligentYellowStateRef.current.yellowStartTime = performance.now();
                    intelligentYellowStateRef.current.vehiclesExited = 0;
                    intelligentYellowStateRef.current.targetExitCount = Math.max(5, greenDirs.length * 3); // 5 vehículos mínimo

                    // Mostrar AMARILLO en TODOS los semáforos
                    try { updateTrafficLights([], 'yellow'); } catch (err) { _noop(err); }
                    console.debug('[GreenWave] Iniciando transición AMARILLA hacia', greenDirs, 'reason=', reason);
                } else {
                    // MODO CLÁSICO: pasar directamente a verde
                    try { updateTrafficLights(greenDirs, 'green'); } catch (err) { _noop(err); }
                }

                // Capturar snapshot de vehículos Y marcas de generación al cambiar de fase
                try {
                    // Incrementar generación (nuevo ciclo de fase)
                    phaseGenerationRef.current++;
                    const newGeneration = phaseGenerationRef.current;

                    // Capturar vehículos que ya están en cola (queueTriggered)
                    // Incluir todos: liberados o no - el punto es contar cuántos había
                    capturedVehicleIdsRef.current = new Set();
                    let capturedCount = 0;
                    ['N', 'S', 'E', 'W'].forEach(dir => {
                        const dirVehicles = vehiclesRef.current[dir] || [];
                        dirVehicles.forEach(v => {
                            if (v.userData.queueTriggered && !v.userData.exitTriggered) {
                                capturedVehicleIdsRef.current.add(v.userData.id || v.uuid);
                                v.userData.phaseGeneration = newGeneration;
                                capturedCount++;
                            }
                        });
                    });

                    console.log(`📋 [FASE ${newGeneration}] axis=${axis} capturados ${capturedCount} vehículos en cola`);

                    // Capturar matriz de distribución
                    const currentCounts = measureWaitingQueues();
                    const axisTotal = axis === 'NS' ? (currentCounts.N + currentCounts.S) : (currentCounts.E + currentCounts.W);

                    const matrix = {
                        N: currentCounts.N,
                        S: currentCounts.S,
                        E: currentCounts.E,
                        W: currentCounts.W,
                        total: axisTotal,
                        proportions: {
                            N: axisTotal > 0 ? currentCounts.N / axisTotal : 0,
                            S: axisTotal > 0 ? currentCounts.S / axisTotal : 0,
                            E: axisTotal > 0 ? currentCounts.E / axisTotal : 0,
                            W: axisTotal > 0 ? currentCounts.W / axisTotal : 0
                        }
                    };
                    phaseDistributionMatrixRef.current = matrix;
                    console.log(`📊 [MATRIZ FASE ${newGeneration}] axis=${axis}:`, matrix);
                } catch (err) { console.warn('phaseDistributionMatrix snapshot error', err); }                // Actualizar tiempos de espera: las direcciones que reciben verde se resetean, las otras incrementan
                try {
                    ['N', 'S', 'E', 'W'].forEach(d => {
                        const prev = waitingTimeByDirectionRef.current[d] || 0;
                        if (greenDirs.includes(d)) {
                            waitingTimeByDirectionRef.current[d] = 0;
                        } else {
                            waitingTimeByDirectionRef.current[d] = Math.min(WAITING_TIME_MAX, prev + 1);
                        }
                    });
                    try { setWaitingTimeDisplay({ ...waitingTimeByDirectionRef.current }); } catch (e) { _noop(e); }
                } catch (err) {
                    console.warn('finalizeChoice waiting time update error', err);
                }

                pushDebug(`GreenWave: decision ${reason || 'auto'} -> ${greenDirs.join(',')} ${axis ? 'axis=' + axis : ''}`);
            };
            const totalQueued = N + S + E + W;
            const nsTotal = N + S;
            const ewTotal = E + W;

            // Si no hay vehículos, NO poner en rojo automáticamente
            if (totalQueued === 0) {
                try {
                    ['N', 'S', 'E', 'W'].forEach(d => waitingTimeByDirectionRef.current[d] = 0);
                    try { setWaitingTimeDisplay({ ...waitingTimeByDirectionRef.current }); } catch (e) { _noop(e); }
                } catch (err) { _noop(err); }
                return;
            }

            // ===== REGLA PRIMORDIAL: EMPTY LANE PRIORITY CON FLEXIBILIDAD =====
            // Si uno o más carriles están COMPLETAMENTE VACÍOS mientras otros tienen vehículos,
            // PRIORIZAR los carriles con vehículos, pero permitir cambios si la situación cambia.
            const counts = [{ d: 'N', c: N }, { d: 'S', c: S }, { d: 'E', c: E }, { d: 'W', c: W }];
            const hasEmpty = counts.some(x => x.c === 0);
            const nonEmpty = counts.filter(x => x.c > 0);

            if (hasEmpty && nonEmpty.length > 0 && nonEmpty.length < 4) {
                // Al menos 1 carril está vacío Y hay vehículos en otros carriles
                let targetAxis = null;

                // Caso 1: Un eje completo está vacío (N=0 y S=0, o E=0 y W=0)
                if (nsTotal === 0 && ewTotal > 0) {
                    targetAxis = 'EW';
                    console.log('🎯 [EmptyLanePriority] NS completamente vacío (0+0), PRIORIZANDO EW:', { E, W });
                } else if (ewTotal === 0 && nsTotal > 0) {
                    targetAxis = 'NS';
                    console.log('🎯 [EmptyLanePriority] EW completamente vacío (0+0), PRIORIZANDO NS:', { N, S });
                } else {
                    // Caso 2: Uno o dos carriles vacíos, pero no un eje completo
                    // Priorizar el eje con MÁS vehículos (pero permitir cambios si otro eje tiene mucho más)
                    const diff = Math.abs(nsTotal - ewTotal);
                    const dominantRatio = Math.max(nsTotal, ewTotal) / Math.max(1, nsTotal + ewTotal);

                    // Si la diferencia es muy grande (uno tiene 3+ veces más), cambiar
                    if (nsTotal >= ewTotal * 3 || ewTotal >= nsTotal * 3) {
                        targetAxis = nsTotal > ewTotal ? 'NS' : 'EW';
                        console.log('🎯 [EmptyLanePriority] Diferencia grande detectada, CAMBIANDO a:', targetAxis);
                    } else if (currentPhaseRef.current && dominantRatio < 0.8) {
                        // Si no hay un claro dominante, permitir cambios naturales
                        console.log('🎯 [EmptyLanePriority] No hay dominante claro, dejando lógica normal...');
                        targetAxis = null; // Dejar que la lógica fallback decida
                    } else {
                        targetAxis = nsTotal >= ewTotal ? 'NS' : 'EW';
                        console.log('🎯 [EmptyLanePriority] Carriles parcialmente vacíos, PRIORIZANDO:', { targetAxis, N, S, E, W });
                    }
                }

                // APLICAR SOLO SI HAY UN CLARO GANADOR
                if (targetAxis) {
                    currentPhaseRef.current = targetAxis;
                    setPhase(targetAxis);
                    lastPriorityAxisRef.current = targetAxis;
                    // IMPORTANTE: Borrar quota anterior para evitar que interfiera
                    adaptivePhaseTargetRef.current = null;
                }

                // AMBOS semáforos del eje deben estar verdes (sin filtrar por waitingCounts)
                // porque los vehículos van en línea recta: N↔S y E↔W
                const greenDirections = targetAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];
                console.log(`🟢🟢🟢 [VERDE SIMULTANEO] targetAxis=${targetAxis} greenDirections=[${greenDirections.join(', ')}] (ambos semáforos verdes) waitingCounts:`, waitingCounts);
                try { setEvaluationArrows(greenDirections); } catch (err) { }
                finalizeChoice(greenDirections, targetAxis, 'empty_lane_priority_RULE_1');
                pushDebug(`[EmptyLanePriority] MANTENIENDO ${targetAxis} (${greenDirections.join(',')}), carriles vacíos: ${counts.filter(x => x.c === 0).map(x => x.d).join(',')}`);
                return;
            }

            // Registrar en el historial (móvil) para la matriz principal SOLO si la medición es válida
            try {
                if (lastMeasurementValidRef.current) {
                    waitingHistoryRef.current.push({ N, S, E, W });
                    if (waitingHistoryRef.current.length > 8) waitingHistoryRef.current.shift();
                } else {
                    // mark that we skipped an invalid measurement
                    pushDebug('GreenWave: skipped updating history - measurement estimated');
                }
            } catch (err) {
                console.warn('waitingHistory push error', err);
            }

            // If we already set an adaptivePhaseTarget with a quota, enforce the quota
            try {
                const adapt = adaptivePhaseTargetRef.current;
                if (adapt && typeof adapt.quotaSum === 'number') {
                    const released = (lastPhaseReleasedRef.current && lastPhaseReleasedRef.current.total) || 0;
                    if (released < adapt.quotaSum) {
                        // continue serving the current adaptive axis until quota met
                        const axis = adapt.axis || currentPhaseRef.current;
                        if (axis) {
                            const greenDirections = axis === 'NS' ? ['N', 'S'] : ['E', 'W'];
                            try { setEvaluationArrows(greenDirections); } catch (err) { }
                            finalizeChoice(greenDirections, axis, 'honoring_quota');
                            console.debug('[GreenWave] honoring quota, axis=', axis, 'released=', released, 'quota=', adapt.quotaSum);
                            return;
                        }
                    }
                }
            } catch (err) {
                console.warn('adaptive quota check error', err);
            }

            // 2) If ALL directions have vehicles -> prioritize the axis with the larger total
            // (avoid enforcing strict per-direction quotas that can keep all semaphores red)
            const allHaveVehicles = N > 0 && S > 0 && E > 0 && W > 0;
            if (allHaveVehicles) {
                let targetAxis = nsTotal >= ewTotal ? 'NS' : 'EW';
                // If an adaptive target exists and it's still reasonable, honor it briefly
                if (adaptivePhaseTargetRef.current && adaptivePhaseTargetRef.current.axis && adaptivePhaseTargetRef.current.axis !== targetAxis) {
                    // allow the previous axis to finish a small release window before switching
                    const prev = adaptivePhaseTargetRef.current.axis;
                    if ((lastPhaseReleasedRef.current.total || 0) < 2) {
                        targetAxis = prev;
                    }
                }

                if (targetAxis !== currentPhaseRef.current) {
                    currentPhaseRef.current = targetAxis;
                    setPhase(targetAxis);
                    lastPriorityAxisRef.current = targetAxis;
                    lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                    const initQ = targetAxis === 'NS' ? nsTotal : ewTotal;
                    // QUOTA AL 100%: vaciar completamente este eje antes de cambiar
                    adaptivePhaseTargetRef.current = { axis: targetAxis, initialQueue: initQ, quotaSum: Math.max(1, Math.ceil(initQ * 1.0)) };
                    pushDebug(`GreenWave: serving axis ${targetAxis} initialQueue=${initQ} quota=${adaptivePhaseTargetRef.current.quotaSum}`);
                }

                const greenDirections = targetAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];
                try { setEvaluationArrows(greenDirections); } catch (err) { console.warn('setEvaluationArrows error', err); }
                finalizeChoice(greenDirections, targetAxis, 'serve_axis_all_have_vehicles');
                return;
            }

            // 3) Prevent accumulation on one axis when others are empty by applying dynamic cap
            const dynamicCap = calculateDynamicThreshold(waitingCounts, selectedHour);
            // If any direction exceeds dynamicCap while another direction is empty, force switch
            const overCapacity = ['N', 'S', 'E', 'W'].find(d => waitingCounts[d] > dynamicCap);
            if (overCapacity) {
                // If opposite side(s) empty, prefer the empty side to avoid accumulation
                if (nsTotal === 0 && ewTotal > 0) {
                    currentPhaseRef.current = 'EW';
                    setPhase('EW');
                    lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                    // QUOTA AL 100%: vaciar completamente este eje
                    adaptivePhaseTargetRef.current = { axis: 'EW', initialQueue: ewTotal, quotaSum: Math.max(1, Math.ceil(ewTotal * 1.0)) };
                    pushDebug(`GreenWave: overCapacity ${overCapacity} -> prioritizing EW initialQueue=${ewTotal} quota=${adaptivePhaseTargetRef.current.quotaSum}`);
                    // AMBOS semáforos E y W verdes (sin filtrar)
                    const greenDirections = ['E', 'W'];
                    try { setEvaluationArrows(greenDirections); } catch (err) { console.warn('setEvaluationArrows error', err); }
                    finalizeChoice(greenDirections, 'overCapacity_switch', 'over_capacity_handling');
                    return;
                }
                if (ewTotal === 0 && nsTotal > 0) {
                    currentPhaseRef.current = 'NS';
                    setPhase('NS');
                    lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                    // QUOTA AL 100%: vaciar completamente este eje
                    adaptivePhaseTargetRef.current = { axis: 'NS', initialQueue: nsTotal, quotaSum: Math.max(1, Math.ceil(nsTotal * 1.0)) };
                    pushDebug(`GreenWave: overCapacity ${overCapacity} -> prioritizing NS initialQueue=${nsTotal} quota=${adaptivePhaseTargetRef.current.quotaSum}`);
                    // AMBOS semáforos N y S verdes (sin filtrar)
                    const greenDirections = ['N', 'S'];
                    try { setEvaluationArrows(greenDirections); } catch (err) { console.warn('setEvaluationArrows error', err); }
                    finalizeChoice(greenDirections, 'overCapacity_switch', 'over_capacity_handling');
                    return;
                }
            }

            // Intentar decisión por carril comparada con la matriz principal
            const laneDecision = decideByLane({ N, S, E, W });
            if (!laneDecision.useFallback) {
                // Aplicar decisión por carril cuando hay histograma suficiente
                const { targetAxis, greenDirections, reason, diffs, mainAvg, overloaded } = laneDecision;
                console.log('🧮 DecisionByLane:', { reason, targetAxis, greenDirections, diffs, mainAvg, overloaded });
                pushDebug(`🧮 DecisionByLane: ${reason} → ${targetAxis} | dirs:${greenDirections.join(',')}`);

                if (targetAxis !== currentPhaseRef.current || currentPhaseRef.current === null) {
                    console.log(`🔄 Cambiando de ${currentPhaseRef.current} a ${targetAxis} (por matriz de carriles)`);
                    currentPhaseRef.current = targetAxis;
                    setPhase(targetAxis);
                    lastPriorityAxisRef.current = targetAxis;
                    lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                    adaptivePhaseTargetRef.current = { axis: targetAxis, initialQueue: 0 };
                }

                try { setEvaluationArrows(greenDirections); } catch (err) { console.warn('setEvaluationArrows error', err); }
                finalizeChoice(greenDirections, targetAxis, 'decision_by_lane');
                return;
            }

            // Si no hay historial suficiente, usar la lógica original de histéresis dinámica
            console.log('🚦 GreenWave (fallback): N=%d S=%d E=%d W=%d (Total: %d)', N, S, E, W, totalQueued);

            // nsTotal/ewTotal already computed above
            const currentAxis = currentPhaseRef.current; // puede ser null
            let targetAxis;

            const HYSTERESIS_MIN = 1;
            const dynamicThresh = Math.max(HYSTERESIS_MIN, Math.round(totalQueued * 0.15));

            // Lógica de hysteresis: MANTENER eje activo hasta que se vacíe
            if (!currentAxis) {
                targetAxis = nsTotal >= ewTotal ? 'NS' : 'EW';
            } else {
                // Si el eje actual tiene vehículos: MANTENERLO
                const currentAxisTotal = currentAxis === 'NS' ? nsTotal : ewTotal;
                const otherAxisTotal = currentAxis === 'NS' ? ewTotal : nsTotal;

                if (currentAxisTotal > 2) {
                    // El eje actual tiene vehículos: MANTENERLO hasta que se vacíe
                    targetAxis = currentAxis;
                } else if (currentAxisTotal === 0 || otherAxisTotal > currentAxisTotal) {
                    // Eje actual vacío o el otro eje tiene MÁS: CAMBIAR al eje con más vehículos
                    targetAxis = nsTotal > ewTotal ? 'NS' : 'EW';
                } else {
                    // Fallback: priorizar el eje con más vehículos
                    targetAxis = nsTotal >= ewTotal ? 'NS' : 'EW';
                }
            }

            console.log(`🔎 [DECISION] currentAxis=${currentAxis} nsTotal=${nsTotal} ewTotal=${ewTotal} → targetAxis=${targetAxis} (mantener si tiene vehículos)`);

            if (targetAxis !== currentAxis || currentPhaseRef.current === null) {
                console.log(`🔄 Cambiando de ${currentAxis} a ${targetAxis}`);
                currentPhaseRef.current = targetAxis;
                setPhase(targetAxis);
                lastPriorityAxisRef.current = targetAxis;
                lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                adaptivePhaseTargetRef.current = { axis: targetAxis, initialQueue: 0 };
            } else {
                currentPhaseRef.current = targetAxis;
            }

            // AMBOS semáforos del eje deben estar verdes (sin filtrar)
            const greenDirections = targetAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];

            try { setEvaluationArrows(greenDirections); } catch (err) { console.warn('setEvaluationArrows error', err); }
            finalizeChoice(greenDirections, targetAxis, 'fallback_decision');
        };        // ===== 8. ALGORITMO ADAPTATIVO =====
        const _selectNextPhase = () => {
            const effectiveMode = getEffectiveMode();
            const { active: accidentActive, location: accidentLocation } = accidentRef.current;
            const counts = measureWaitingQueues();

            let chosenAxis;

            // LÓGICA SEGÚN MODO DE SEMÁFORO Y ACCIDENTE
            if (accidentActive) {
                // Durante un accidente, detener TODAS las direcciones (modo seguro) independientemente del modo
                chosenAxis = null; // sin eje activo
                lastPriorityAxisRef.current = null;
                currentPhaseRef.current = null;
                setPhase('PAUSA');
                // Forzar todos los semáforos en rojo
                try { updateTrafficLights([], 'green'); } catch (e) { }
                // Reiniciar contadores de liberados por fase
                lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };
                return chosenAxis;
            } else {
                // SIN ACCIDENTE: algoritmo normal adaptativo
                const nsCount = counts.N + counts.S;
                const ewCount = counts.E + counts.W;

                if (nsCount === 0 && ewCount === 0) {
                    chosenAxis = lastPriorityAxisRef.current === 'NS' ? 'EW' : 'NS';
                } else if (nsCount > ewCount) {
                    chosenAxis = 'NS';
                } else if (ewCount > nsCount) {
                    chosenAxis = 'EW';
                } else {
                    chosenAxis = lastPriorityAxisRef.current === 'NS' ? 'EW' : 'NS';
                }
            }

            lastPriorityAxisRef.current = chosenAxis;
            currentPhaseRef.current = chosenAxis;
            setPhase(chosenAxis);

            // Reset de liberados por fase para el panel de análisis
            lastPhaseReleasedRef.current = { N: 0, S: 0, E: 0, W: 0, total: 0 };

            const activeDirections = chosenAxis === 'NS' ? ['N', 'S'] : ['E', 'W'];
            try { setEvaluationArrows(activeDirections); } catch (err) { console.warn('setEvaluationArrows error', err); }
            updateTrafficLights(activeDirections);

            return chosenAxis;
        };

        // ===== 9. ANIMAR VEHÍCULOS =====
        const updateVehicles = () => {
            const vehiclesToRemove = [];
            const effectiveMode = getEffectiveMode();

            // Calcular límite dinámico de vehículos según colas
            const waitingCounts = measureWaitingQueues();
            const nsTotal = waitingCounts.N + waitingCounts.S;
            const ewTotal = waitingCounts.E + waitingCounts.W;
            const totalQueued = nsTotal + ewTotal;
            const activeAxis = currentPhaseRef.current;

            // Actualizar matriz de distribución dinámica cada 30 frames (~500ms)
            if (effectiveMode === 'intelligent' && tickRef.current % 30 === 0) {
                try {
                    const axisTotal = activeAxis === 'NS' ? nsTotal : ewTotal;
                    if (axisTotal > 0) {
                        phaseDistributionMatrixRef.current = {
                            N: waitingCounts.N,
                            S: waitingCounts.S,
                            E: waitingCounts.E,
                            W: waitingCounts.W,
                            total: axisTotal,
                            proportions: {
                                N: activeAxis === 'NS' ? waitingCounts.N / axisTotal : 0,
                                S: activeAxis === 'NS' ? waitingCounts.S / axisTotal : 0,
                                E: activeAxis === 'EW' ? waitingCounts.E / axisTotal : 0,
                                W: activeAxis === 'EW' ? waitingCounts.W / axisTotal : 0
                            }
                        };
                    }
                } catch (err) { _noop(err); }
            }

            // Calcular cuántos vehículos despachar en esta fase
            let maxVehiclesPerDir;

            if (effectiveMode === 'intelligent') {
                // MODO GREENWAVE: SIN LÍMITE - liberar todos los vehículos que lleguen al semáforo
                maxVehiclesPerDir = 9999;
            } else {
                // MODO CLÁSICO: límite dinámico basado en proporción
                maxVehiclesPerDir = 50; // Base mínimo

                if (totalQueued > 0) {
                    if (activeAxis === 'NS') {
                        const nsProportion = nsTotal / totalQueued;
                        maxVehiclesPerDir = 50 + (nsProportion * 150);
                    } else {
                        const ewProportion = ewTotal / totalQueued;
                        maxVehiclesPerDir = 50 + (ewProportion * 150);
                    }
                }
                // Limitar a máximo 200 para modo clásico
                maxVehiclesPerDir = Math.min(200, Math.round(maxVehiclesPerDir));
            }

            const pendingMoves = [];
            ['N', 'S', 'E', 'W'].forEach(direction => {
                const dirVehicles = vehiclesRef.current[direction];
                // Ordena por progreso para aplicar headway de líder a seguidor
                dirVehicles.sort((a, b) => b.userData.progress - a.userData.progress);
                // Resolve which physical semaphore corresponds to this logical lane
                const laneMap = laneToSemaphoreMapRef.current || {};
                const semKey = laneMap[direction] || direction;
                let semaphoreState = (semaphores[semKey] && semaphores[semKey].userData && semaphores[semKey].userData.state) || 'red';
                // DEBUG: mostrar líder y estado del semáforo (una vez por tick por dirección)
                try {
                    const leader = dirVehicles[0];
                    if (leader) {
                        console.debug(`[DBG] leader ${direction} (sem=${semKey}) progress=${leader.userData.progress.toFixed(3)} inEntry=${leader.userData.inEntryLane} released=${leader.userData.released} semState=${semaphoreState}`);
                    } else {
                        console.debug(`[DBG] leader ${direction} none (sem=${semKey}) semState=${semaphoreState}`);
                    }
                } catch (e) { }
                let releasedThisPhase = 0;

                dirVehicles.forEach((vehicle, idx) => {
                    const { progress, inEntryLane, released } = vehicle.userData;
                    const baseSpeed = vehicle.userData.baseSpeed ?? vehicle.userData.speed ?? 0.007;

                    // Multiplicadores de velocidad:
                    // 1. Global (slider de velocidad de simulación)
                    // 2. Transición amarilla (aceleración/desaceleración gradual)
                    const globalSpeedMult = speedMultiplierRef.current || 1;
                    const yellowMult = getYellowTransitionSpeedMultiplier(direction, yellowTransitionRef.current);
                    const effectiveSpeed = baseSpeed * globalSpeedMult * yellowMult;

                    // ===== LÓGICA DE ACCIDENTE =====
                    const effectiveMode = getEffectiveMode();
                    const { active: accidentActive, location: accidentLocation } = accidentRef.current;
                    let isAffectedByAccident = false;

                    if (accidentActive && direction === accidentLocation) {
                        // Zona del accidente
                        const accidentZoneStart = 0.05;
                        const accidentZoneEnd = 0.9;

                        // Solo afectar a vehículos que NO han sido liberados (para que pasen los que ya cruzaron)
                        if (!released) {
                            if (effectiveMode === 'classic') {
                                // MODO CLÁSICO: Bloquea una zona más amplia (desde antes del accidente)
                                if (progress > 0.2 && progress < 0.8) {
                                    isAffectedByAccident = true;
                                }
                            } else if (effectiveMode === 'intelligent') {
                                // MODO INTELIGENTE/GREENWAVE: Solo detiene los que están en el accidente
                                if (progress > accidentZoneStart && progress < accidentZoneEnd) {
                                    isAffectedByAccident = true;
                                }
                            }
                        }
                    }

                    // Detenerse antes del semáforo; la ventana evita que crucen la línea de pare
                    const atStopLine = inEntryLane && progress >= STOP_LINE_PROGRESS && progress < STOP_LINE_PROGRESS + STOP_LINE_WINDOW;

                    // Disparar el trigger de cola al acercarse al semáforo
                    if (inEntryLane && !vehicle.userData.queueTriggered && progress >= QUEUE_TRIGGER_PROGRESS) {
                        vehicle.userData.queueTriggered = true;
                        // mark entry time for wait-time calculation
                        try { vehicle.userData.entryTime = performance.now(); } catch (e) { vehicle.userData.entryTime = Date.now(); }
                        console.debug(`[DBG] queueTriggered ${direction} progress=${progress.toFixed(3)}`);
                    }

                    // Disparar trigger de salida al otro lado del cruce
                    // Respetar flag `ignoreExitUntil` para vehículos que acaban de girar
                    const ignoreUntil = vehicle.userData.ignoreExitUntil;
                    const isIgnoringExit = (typeof ignoreUntil === 'number') && (vehicle.userData.progress < ignoreUntil);
                    if (!inEntryLane && !vehicle.userData.exitTriggered && progress >= EXIT_TRIGGER_PROGRESS && !isIgnoringExit) {
                        vehicle.userData.exitTriggered = true;
                        // Ya no cuenta para cola de espera
                        vehicle.userData.queueTriggered = false;
                        console.debug(`[DBG] exitTriggered ${direction} progress=${progress.toFixed(3)}`);
                    }

                    let canMove = true;

                    // Accidente: detener vehículos afectados
                    if (isAffectedByAccident) {
                        canMove = false;
                    } else if (atStopLine && semaphoreState === 'red') {
                        canMove = false;
                    }

                    if (atStopLine && semaphoreState === 'green' && !released) {
                        // En modo inteligente, LIBERAR vehículos capturados Y permitir algunos extras
                        if (effectiveMode === 'intelligent') {
                            const vehicleId = vehicle.userData.id || vehicle.uuid;
                            const isCaptured = capturedVehicleIdsRef.current.has(vehicleId);

                            // Lógica: 
                            // - Vehículos capturados: liberar SIN LÍMITE
                            // - Vehículos nuevos: permitir hasta 50% más que los capturados (para fluidez)
                            const capturedCount = capturedVehicleIdsRef.current.size;
                            const extraAllowed = Math.ceil(capturedCount * 0.5); // 50% extra
                            const totalAllowed = capturedCount + extraAllowed;

                            if (releasedThisPhase < totalAllowed) {
                                vehicle.userData.released = true;
                                releasedThisPhase++;
                            } else {
                                canMove = false;
                            }
                        } else {
                            // Modo clásico: sí hay límite por fase
                            if (releasedThisPhase >= maxVehiclesPerDir) {
                                canMove = false;
                            } else {
                                vehicle.userData.released = true;
                                releasedThisPhase++;
                            }
                        }
                    }                    // DIAGNÓSTICO: Si un vehículo se mueve con semáforo en rojo y no fue previamente liberado, lo registramos
                    try {
                        if (semaphoreState === 'red' && canMove && !vehicle.userData.released && atStopLine) {
                            console.error(`[ILLEGAL] vehicle moving on RED [${direction}] progress=${vehicle.userData.progress.toFixed(3)} released=${vehicle.userData.released}`);
                            pushDebug(`[ILLEGAL] vehicle moving on RED [${direction}] progress=${vehicle.userData.progress.toFixed(3)}`);
                        }
                    } catch (e) { }

                    let targetProgress = progress;
                    if (canMove) {
                        targetProgress = progress + effectiveSpeed;
                    }

                    // Mantener distancia con el vehículo líder
                    if (idx > 0) {
                        const leader = dirVehicles[idx - 1];
                        const leaderProgress = leader.userData.progress;
                        const maxAllowed = leaderProgress - MIN_HEADWAY_PROGRESS;
                        if (targetProgress > maxAllowed) {
                            targetProgress = Math.max(progress, maxAllowed);
                        }
                    }

                    vehicle.userData.progress = targetProgress;

                    const p = vehicle.userData.progress;

                    // Plan right-turns only after the vehicle has cleared the semaphore (exit area)
                    if (vehicle.userData.inEntryLane && p >= EXIT_TRIGGER_PROGRESS) {
                        vehicle.userData.inEntryLane = false;
                        console.debug(`[DBG] inEntryLane->false (post-semaphore) ${direction} progress=${p.toFixed(3)}`);
                        // Plan turn only if allowed and not already turning
                        try {
                            if (ENABLE_TURNS && vehicle.userData.turnPossible && !vehicle.userData.turning && Math.random() < 0.5) {
                                // plan a right turn
                                const rightMap = { N: 'E', E: 'S', S: 'W', W: 'N' };
                                const target = rightMap[direction];
                                // Determine end position from the configured exit trigger for the target direction
                                const startPos = vehicle.position.clone();
                                let endPos = null;
                                try {
                                    const exitTrigger = exitTriggerZonesRef.current?.[target];
                                    if (exitTrigger && exitTrigger.position) {
                                        endPos = exitTrigger.position.clone();
                                        endPos.y = 1;
                                    }
                                } catch (e) { }
                                // Fallback approximate end positions if exit trigger isn't available
                                if (!endPos) {
                                    const fallback = { N: new THREE.Vector3(LANE_OFFSET, 1, -EXIT_TRIGGER_OFFSET), S: new THREE.Vector3(-LANE_OFFSET, 1, EXIT_TRIGGER_OFFSET), E: new THREE.Vector3(EXIT_TRIGGER_OFFSET, 1, LANE_OFFSET), W: new THREE.Vector3(-EXIT_TRIGGER_OFFSET, 1, -LANE_OFFSET) };
                                    endPos = fallback[target].clone();
                                }
                                const approachVecs = { N: new THREE.Vector3(0, 0, -1), S: new THREE.Vector3(0, 0, 1), E: new THREE.Vector3(1, 0, 0), W: new THREE.Vector3(-1, 0, 0) };
                                const exitVecs = { N: new THREE.Vector3(0, 0, -1), S: new THREE.Vector3(0, 0, 1), E: new THREE.Vector3(1, 0, 0), W: new THREE.Vector3(-1, 0, 0) };
                                const cp1 = startPos.clone().add(approachVecs[direction].clone().multiplyScalar(6));
                                const cp2 = endPos.clone().sub(exitVecs[target].clone().multiplyScalar(6));
                                vehicle.userData.turning = true;
                                vehicle.userData.turnData = {
                                    startPos,
                                    endPos,
                                    cp1,
                                    cp2,
                                    startRot: vehicle.rotation.y,
                                    endRot: (target === 'N' ? 0 : target === 'S' ? Math.PI : target === 'E' ? Math.PI / 2 : -Math.PI / 2),
                                    targetDir: target,
                                    startProgress: p
                                };
                                // prevent exit trigger from firing during and immediately after the turn
                                const _turnStart = Math.max(STOP_LINE_PROGRESS + 0.06, EXIT_TRIGGER_PROGRESS - 0.02);
                                const _turnSpan = 0.35; // tighter span so turn completes earlier
                                vehicle.userData.ignoreExitUntil = Math.min(0.95, _turnStart + _turnSpan + 0.03);
                                console.debug('[TURN] planned (post-semaphore)', direction, '->', target, vehicle.userData.turnData);
                            }
                        } catch (e) { }
                    }

                    // Movimiento según dirección (sin desplazar a otra vía, mantiene su carril)
                    if (ENABLE_TURNS && vehicle.userData.turning && vehicle.userData.turnData) {
                        // animate along cubic Bezier based on local turn progress derived from overall progress
                        // Start turning shortly after the stop line so the maneuver happens just after the semaphore
                        const TURN_START = Math.max(STOP_LINE_PROGRESS + 0.06, EXIT_TRIGGER_PROGRESS - 0.02);
                        const TURN_SPAN = 0.35; // shorter span so turn finishes well before the next semaphore
                        const t = Math.min(1, Math.max(0, (p - TURN_START) / TURN_SPAN));
                        const td = vehicle.userData.turnData;
                        // cubic bezier: B(t) = (1-t)^3 P0 + 3(1-t)^2 t P1 + 3(1-t) t^2 P2 + t^3 P3
                        const omt = 1 - t;
                        const p0 = td.startPos, p1 = td.cp1, p2 = td.cp2, p3 = td.endPos;
                        const pos = new THREE.Vector3(0, 0, 0);
                        pos.addScaledVector(p0, omt * omt * omt);
                        pos.addScaledVector(p1, 3 * omt * omt * t);
                        pos.addScaledVector(p2, 3 * omt * t * t);
                        pos.addScaledVector(p3, t * t * t);
                        vehicle.position.copy(pos);
                        // rotation interpolation (shortest) - use robust modulo to avoid JS % negative quirks
                        const a0 = td.startRot;
                        const a1 = td.endRot;
                        const twoPi = 2 * Math.PI;
                        let da = (a1 - a0) % twoPi;
                        if (da < -Math.PI) da += twoPi;
                        if (da > Math.PI) da -= twoPi;
                        vehicle.rotation.y = a0 + da * t;
                        if (t >= 1) {
                            // complete turn: reassign vehicle to the new logical direction so it continues
                            const targetDir = td.targetDir;
                            vehicle.userData.turning = false;
                            vehicle.userData.turnData = null;
                            vehicle.userData.direction = targetDir;
                            // place vehicle slightly ahead on the new lane by setting progress to 0.5
                            // map final progress to slightly ahead in the exit lane to avoid immediate exit-trigger
                            vehicle.userData.progress = 0.6;
                            vehicle.userData.inEntryLane = false;
                            vehicle.rotation.y = td.endRot;
                            // schedule move between direction arrays after loop to avoid mutating current iteration
                            pendingMoves.push({ vehicle, from: direction, to: targetDir });
                        }
                    } else {
                        // If turns are globally disabled but a vehicle somehow still has a turning flag (stale state),
                        // cancel the turn immediately and fall back to lane-aligned movement so it doesn't look wrong.
                        if (!ENABLE_TURNS && vehicle.userData.turning) {
                            vehicle.userData.turning = false;
                            vehicle.userData.turnData = null;
                            // ensure the vehicle remains in the same logical lane and let regular movement code position it
                            vehicle.userData.inEntryLane = false;
                            console.debug('[TURN] cancelled (global disable) for', vehicle.uuid);
                        }
                        if (direction === 'N') {
                            vehicle.position.z = STREET_LENGTH / 2 - (p * STREET_LENGTH);
                        } else if (direction === 'S') {
                            vehicle.position.z = -STREET_LENGTH / 2 + (p * STREET_LENGTH);
                        } else if (direction === 'E') {
                            vehicle.position.x = -STREET_LENGTH / 2 + (p * STREET_LENGTH);
                        } else if (direction === 'W') {
                            vehicle.position.x = STREET_LENGTH / 2 - (p * STREET_LENGTH);
                        }
                    }

                    // Actualizar collider del vehículo con su posición actual (después de moverlo)
                    if (vehicle.userData.collider) {
                        try {
                            vehicle.userData.collider.setFromObject(vehicle);
                        } catch (e) {
                            vehicle.userData.collider.setFromCenterAndSize(
                                vehicle.position,
                                vehicle.userData.colliderSize
                            );
                        }
                    }

                    // Update vehicle collider debug helper (if present)
                    try {
                        const dbg = vehicle.userData.debugHelper;
                        if (dbg && typeof dbg.update === 'function') {
                            dbg.update();
                        }
                    } catch (e) { _noop(e); }

                    // Detect exit by intersection against any exit trigger bbox (more robust than progress-only)
                    const ignoreUntil2 = vehicle.userData.ignoreExitUntil;
                    const isIgnoringExit2 = (typeof ignoreUntil2 === 'number') && (vehicle.userData.progress < ignoreUntil2);
                    if (!vehicle.userData.exitTriggered && vehicle.userData.collider) {
                        const exitZones = exitTriggerZonesRef.current || {};
                        for (const [exitDir, exitTrigger] of Object.entries(exitZones)) {
                            try {
                                const ebbox = exitTrigger?.userData?.bbox;
                                if (ebbox && vehicle.userData.collider.intersectsBox(ebbox)) {
                                    if (isIgnoringExit2) {
                                        // still in grace period after a turn
                                        break;
                                    }
                                    vehicle.userData.exitTriggered = true;
                                    vehicle.userData.queueTriggered = false;
                                    // attribute stats to the exit trigger's direction
                                    const attributedDir = exitDir;
                                    if (!vehicle.userData.countedExit) {
                                        vehicle.userData.countedExit = true;
                                        statsRef.current.totalReleased++;
                                        releasedTotalsRef.current[attributedDir] = (releasedTotalsRef.current[attributedDir] || 0) + 1;
                                        lastPhaseReleasedRef.current[attributedDir] = (lastPhaseReleasedRef.current[attributedDir] || 0) + 1;
                                        lastPhaseReleasedRef.current.total = (lastPhaseReleasedRef.current.total || 0) + 1;
                                        // Update persistent efficiency accumulators (per-mode)
                                        try {
                                            // Determine the current mode robustly: prefer the ref, fallback to state
                                            const curMode = (trafficModeRef && trafficModeRef.current) ? trafficModeRef.current : (trafficLightMode || 'classic');
                                            let modeKey = 'classic';
                                            if (curMode === 'greenwave' || curMode === 'greenwave_mode') modeKey = 'intelligent';
                                            else if (curMode === 'intelligent') modeKey = 'intelligent';
                                            else modeKey = 'classic';

                                            // Ensure accumulator object exists (defensive initialization)
                                            if (!efficiencyStatsRef.current[modeKey]) {
                                                efficiencyStatsRef.current[modeKey] = {
                                                    totalLiberados: { N: 0, S: 0, E: 0, W: 0, total: 0 },
                                                    totalEnCola: { N: 0, S: 0, E: 0, W: 0 },
                                                    tiempoEsperaAcumulado: { N: 0, S: 0, E: 0, W: 0 },
                                                    prevSnapshotTotalLiberados: 0
                                                };
                                            }

                                            const eff = efficiencyStatsRef.current[modeKey];
                                            eff.totalLiberados[attributedDir] = (eff.totalLiberados[attributedDir] || 0) + 1;
                                            eff.totalLiberados.total = (eff.totalLiberados.total || 0) + 1;
                                            console.debug('[Perf][EXIT] eff.totalLiberados increment', modeKey, attributedDir, 'dirTotal=', eff.totalLiberados[attributedDir], 'total=', eff.totalLiberados.total);
                                            try { pushDebug(`[Perf][EXIT] ${modeKey} ${attributedDir} dir=${eff.totalLiberados[attributedDir]} total=${eff.totalLiberados.total}`); } catch (e) { _noop(e); }
                                            // accumulate waiting time if entryTime exists
                                            try {
                                                const now = performance.now();
                                                const entry = vehicle.userData.entryTime;
                                                if (typeof entry === 'number') {
                                                    const waitMs = Math.max(0, now - entry);
                                                    eff.tiempoEsperaAcumulado[attributedDir] = (eff.tiempoEsperaAcumulado[attributedDir] || 0) + waitMs;
                                                }
                                            } catch (e) { _noop(e); }
                                        } catch (e) { _noop(e); }
                                        // performance tracking: compute wait time if available
                                        try {
                                            const now = performance.now();
                                            const entry = vehicle.userData.entryTime;
                                            if (typeof entry === 'number') {
                                                const waitMs = Math.max(0, now - entry);
                                                const modeKey = getEffectiveMode();
                                                if (modeKey && perfRef.current[modeKey]) {
                                                    perfRef.current[modeKey].waitTimes.push(waitMs);
                                                }
                                            }
                                        } catch (e) { }
                                        // Debug: increment global exit counters and log
                                        try {
                                            const curMode2 = (trafficModeRef && trafficModeRef.current) ? trafficModeRef.current : (trafficLightMode || 'classic');
                                            const modeKey2 = (curMode2 === 'greenwave' || curMode2 === 'intelligent') ? 'intelligent' : 'classic';
                                            exitCountRef.current[modeKey2] = (exitCountRef.current[modeKey2] || 0) + 1;
                                            currentRunCountersRef.current[modeKey2] = (currentRunCountersRef.current[modeKey2] || 0) + 1;
                                            try { pushDebug(`[Exit][COUNTED] mode=${modeKey2} dir=${attributedDir} uuid=${vehicle.uuid}`); } catch (e) { _noop(e); }
                                            try { exitLogRef.current.unshift({ mode: modeKey2, dir: attributedDir, uuid: vehicle.uuid, ts: Date.now() }); if (exitLogRef.current.length > 40) exitLogRef.current.length = 40; } catch (e) { _noop(e); }
                                        } catch (e) { _noop(e); }
                                        // increment release counter used for GreenWave snapshots
                                        try { releasedSinceLastEvalRef.current = (releasedSinceLastEvalRef.current || 0) + 1; } catch (e) { _noop(e); }
                                        // mark that this semaphore saw activity during a green window
                                        try {
                                            const semState = semaphores?.[attributedDir]?.userData?.state || 'red';
                                            if (semState === 'green') {
                                                const g = greenActiveInfoRef.current[attributedDir];
                                                if (g) g.hadVehicle = true;
                                            }
                                        } catch (e) { _noop(e); }
                                    }
                                    // Do NOT remove here; let the vehicle travel until end-of-path so it doesn't disappear abruptly
                                    console.debug(`[DBG] exitIntersect vehicle ${vehicle.uuid} from ${direction} hitExit ${attributedDir} pos=${vehicle.position.x.toFixed(1)},${vehicle.position.z.toFixed(1)}`);
                                    break;
                                }
                            } catch (e) { _noop(e); }
                        }
                        // Fallback: sometimes bbox intersections miss (LOD/precision). If vehicle progressed past
                        // the exit-trigger approx, count it as an exit attributed to its logical direction.
                        try {
                            if (!vehicle.userData.exitTriggered && vehicle.userData.progress >= (EXIT_TRIGGER_PROGRESS - 0.02)) {
                                const attributedDir = vehicle.userData.direction || direction;
                                vehicle.userData.exitTriggered = true;
                                if (!vehicle.userData.countedExit) {
                                    vehicle.userData.countedExit = true;
                                    statsRef.current.totalReleased++;
                                    releasedTotalsRef.current[attributedDir] = (releasedTotalsRef.current[attributedDir] || 0) + 1;
                                    lastPhaseReleasedRef.current[attributedDir] = (lastPhaseReleasedRef.current[attributedDir] || 0) + 1;
                                    lastPhaseReleasedRef.current.total = (lastPhaseReleasedRef.current.total || 0) + 1;
                                    // update efficiency accumulators defensively
                                    try {
                                        const curMode = (trafficModeRef && trafficModeRef.current) ? trafficModeRef.current : (trafficLightMode || 'classic');
                                        const modeKey = (curMode === 'greenwave' || curMode === 'intelligent') ? 'intelligent' : 'classic';
                                        if (!efficiencyStatsRef.current[modeKey]) {
                                            efficiencyStatsRef.current[modeKey] = { totalLiberados: { N: 0, S: 0, E: 0, W: 0, total: 0 }, totalEnCola: { N: 0, S: 0, E: 0, W: 0 }, tiempoEsperaAcumulado: { N: 0, S: 0, E: 0, W: 0 }, prevSnapshotTotalLiberados: 0 };
                                        }
                                        const eff = efficiencyStatsRef.current[modeKey];
                                        eff.totalLiberados[attributedDir] = (eff.totalLiberados[attributedDir] || 0) + 1;
                                        eff.totalLiberados.total = (eff.totalLiberados.total || 0) + 1;
                                        try { pushDebug(`[Perf][EXIT-FALLBACK] ${modeKey} ${attributedDir} dir=${eff.totalLiberados[attributedDir]} total=${eff.totalLiberados.total}`); } catch (e) { _noop(e); }
                                    } catch (e) { _noop(e); }
                                    // perf wait calculation
                                    try {
                                        const now = performance.now();
                                        const entry = vehicle.userData.entryTime;
                                        if (typeof entry === 'number') {
                                            const waitMs = Math.max(0, now - entry);
                                            const modeKeyPerf = getEffectiveMode();
                                            if (modeKeyPerf && perfRef.current[modeKeyPerf]) perfRef.current[modeKeyPerf].waitTimes.push(waitMs);
                                        }
                                    } catch (e) { _noop(e); }
                                    try { releasedSinceLastEvalRef.current = (releasedSinceLastEvalRef.current || 0) + 1; } catch (e) { _noop(e); }
                                    // exit counters/logs
                                    try {
                                        const curMode2 = (trafficModeRef && trafficModeRef.current) ? trafficModeRef.current : (trafficLightMode || 'classic');
                                        const modeKey2 = (curMode2 === 'greenwave' || curMode2 === 'intelligent') ? 'intelligent' : 'classic';
                                        exitCountRef.current[modeKey2] = (exitCountRef.current[modeKey2] || 0) + 1;
                                        currentRunCountersRef.current[modeKey2] = (currentRunCountersRef.current[modeKey2] || 0) + 1;
                                        exitLogRef.current.unshift({ mode: modeKey2, dir: attributedDir, uuid: vehicle.uuid, ts: Date.now() }); if (exitLogRef.current.length > 40) exitLogRef.current.length = 40;
                                        try { pushDebug(`[Exit][FALLBACK] mode=${modeKey2} dir=${attributedDir} uuid=${vehicle.uuid}`); } catch (e) { _noop(e); }
                                    } catch (e) { _noop(e); }
                                }
                                // Do NOT remove here; let end-of-path handle removal to avoid early disappear
                            }
                        } catch (e) { _noop(e); }
                    }

                    if (p >= 1.0) {
                        // reached end of path — attribute to its current direction and remove
                        if (!vehicle.userData.countedExit) {
                            vehicle.userData.countedExit = true;
                            statsRef.current.totalReleased++;
                            releasedTotalsRef.current[direction] = (releasedTotalsRef.current[direction] || 0) + 1;
                            lastPhaseReleasedRef.current[direction] = (lastPhaseReleasedRef.current[direction] || 0) + 1;
                            lastPhaseReleasedRef.current.total = (lastPhaseReleasedRef.current.total || 0) + 1;
                            try {
                                const now = performance.now();
                                const entry = vehicle.userData.entryTime;
                                if (typeof entry === 'number') {
                                    const waitMs = Math.max(0, now - entry);
                                    const modeKey = getEffectiveMode();
                                    if (modeKey && perfRef.current[modeKey]) perfRef.current[modeKey].waitTimes.push(waitMs);
                                    // Also update efficiency accumulators per mode
                                    try {
                                        if (modeKey && efficiencyStatsRef && efficiencyStatsRef.current && efficiencyStatsRef.current[modeKey]) {
                                            const eff = efficiencyStatsRef.current[modeKey];
                                            eff.totalLiberados[direction] = (eff.totalLiberados[direction] || 0) + 1;
                                            eff.totalLiberados.total = (eff.totalLiberados.total || 0) + 1;
                                            console.debug('[Perf][ENDPATH] eff.totalLiberados increment', modeKey, direction, 'dirTotal=', eff.totalLiberados[direction], 'total=', eff.totalLiberados.total);
                                            try { pushDebug(`[Perf][ENDPATH] ${modeKey} ${direction} dir=${eff.totalLiberados[direction]} total=${eff.totalLiberados.total}`); } catch (e) { }
                                            eff.tiempoEsperaAcumulado[direction] = (eff.tiempoEsperaAcumulado[direction] || 0) + waitMs;
                                        }
                                    } catch (ee) { }
                                }
                            } catch (e) { }
                            // Debug: increment global exit counters and log for end-of-path exits
                            try {
                                const curMode3 = (trafficModeRef && trafficModeRef.current) ? trafficModeRef.current : (trafficLightMode || 'classic');
                                const modeKey3 = (curMode3 === 'greenwave' || curMode3 === 'intelligent') ? 'intelligent' : 'classic';
                                exitCountRef.current[modeKey3] = (exitCountRef.current[modeKey3] || 0) + 1;
                                currentRunCountersRef.current[modeKey3] = (currentRunCountersRef.current[modeKey3] || 0) + 1;
                                try { pushDebug(`[Exit][ENDPATH] mode=${modeKey3} dir=${direction} uuid=${vehicle.uuid}`); } catch (e) { _noop(e); }
                                try { exitLogRef.current.unshift({ mode: modeKey3, dir: direction, uuid: vehicle.uuid, ts: Date.now() }); if (exitLogRef.current.length > 40) exitLogRef.current.length = 40; } catch (e) { _noop(e); }
                            } catch (e) { _noop(e); }
                            try { releasedSinceLastEvalRef.current = (releasedSinceLastEvalRef.current || 0) + 1; } catch (e) { }
                            try {
                                const semState = semaphores?.[direction]?.userData?.state || 'red';
                                if (semState === 'green') {
                                    const g = greenActiveInfoRef.current[direction];
                                    if (g) g.hadVehicle = true;
                                }
                            } catch (e) { }
                        }
                        vehiclesToRemove.push({ from: direction, exitDir: direction, vehicle });
                    }
                });
                // end dirVehicles forEach
            });

            // process pending moves (reassign vehicles to target direction arrays)
            pendingMoves.forEach(m => {
                try {
                    const { vehicle, from, to } = m;
                    const fromArr = vehiclesRef.current[from] || [];
                    const idx = fromArr.indexOf(vehicle);
                    if (idx > -1) fromArr.splice(idx, 1);
                    vehiclesRef.current[to] = vehiclesRef.current[to] || [];
                    vehiclesRef.current[to].push(vehicle);
                } catch (e) { console.warn('pendingMoves error', e); }
            });

            vehiclesToRemove.forEach(({ from, exitDir, vehicle }) => {
                try {
                    scene.remove(vehicle);
                    vehicle.geometry?.dispose();
                    vehicle.material?.dispose();
                } catch (e) { }
                // Try to remove the vehicle from whichever lane array contains it
                const dirs = ['N', 'S', 'E', 'W'];
                let removed = false;
                for (const d of dirs) {
                    const arr = vehiclesRef.current[d] || [];
                    const idx = arr.indexOf(vehicle);
                    if (idx > -1) {
                        arr.splice(idx, 1);
                        removed = true;
                        break;
                    }
                }
                if (!removed) {
                    // as a fallback, try the 'from' bucket
                    const fallbackArr = vehiclesRef.current[from] || [];
                    const idx2 = fallbackArr.indexOf(vehicle);
                    if (idx2 > -1) fallbackArr.splice(idx2, 1);
                }
                // Also remove debug helper if exists
                try {
                    const dbgHelper = vehicle.userData.debugHelper;
                    if (dbgHelper) {
                        scene.remove(dbgHelper);
                        dbgHelper.geometry?.dispose?.();
                        dbgHelper.material?.dispose?.();
                    }
                } catch (e) { }
            });
        };

        // ===== 10. ESTADÍSTICAS =====
        const updateStatsDisplay = () => {
            const active = { N: 0, S: 0, E: 0, W: 0 };

            const waiting = measureWaitingQueues();

            ['N', 'S', 'E', 'W'].forEach(dir => {
                vehiclesRef.current[dir].forEach(v => {
                    if (!v.userData.inEntryLane || v.userData.progress >= STOP_LINE_PROGRESS) {
                        active[dir]++;
                    }
                });
            });

            const totalVehicles = Object.values(waiting).reduce((a, b) => a + b, 0) +
                Object.values(active).reduce((a, b) => a + b, 0);

            const efficiency = totalVehicles > 0
                ? Math.round((statsRef.current.totalReleased / totalVehicles) * 100)
                : 0;

            // Calcular metadatos de vehículos
            const metadata = {
                byType: {},
                byTrigger: {}
            };

            ['N', 'S', 'E', 'W'].forEach(dir => {
                const dirVehicles = vehiclesRef.current[dir] || [];
                metadata.byType[dir] = {
                    cars: dirVehicles.filter(v => v.userData.type === 'car').length,
                    buses: dirVehicles.filter(v => v.userData.type === 'bus').length,
                    motorcycles: dirVehicles.filter(v => v.userData.type === 'motorcycle').length
                };
                // Prefer precise trigger-based measured counts when available
                const measured = lastMeasuredCountsRef.current && lastMeasurementValidRef.current ? (lastMeasuredCountsRef.current[dir] || 0) : null;
                metadata.byTrigger[dir] = {
                    inQueue: (measured != null) ? measured : dirVehicles.filter(v => v.userData.queueTriggered && v.userData.inEntryLane).length,
                    released: dirVehicles.filter(v => v.userData.released).length,
                    exitTriggered: dirVehicles.filter(v => v.userData.exitTriggered).length
                };
            });

            // Conteo exacto de vehículos renderizados (1:1 con lo visible en escena)
            const rendered = { total: 0, byType: { car: 0, bus: 0, motorcycle: 0 } };
            ['N', 'S', 'E', 'W'].forEach(dir => {
                vehiclesRef.current[dir].forEach(v => {
                    rendered.total += 1;
                    if (v.userData.type === 'car') rendered.byType.car += 1;
                    if (v.userData.type === 'bus') rendered.byType.bus += 1;
                    if (v.userData.type === 'motorcycle') rendered.byType.motorcycle += 1;
                });
            });

            // Build efficiency comparison between Classic and GreenWave (intelligent)
            const avgFromHistory = (hist) => {
                if (!hist || hist.length === 0) return null;
                const n = hist.length;
                const avg = { avgWaitSec: null, released: null, effectivePercent: null, wastedPercent: null, queueEndCounts: null };
                // avgWaitSec
                const waits = hist.map(h => h.avgWaitSec).filter(v => v != null);
                if (waits.length) avg.avgWaitSec = Math.round((waits.reduce((a, b) => a + b, 0) / waits.length) * 10) / 10;
                const rels = hist.map(h => h.released).filter(v => v != null);
                if (rels.length) avg.released = Math.round(rels.reduce((a, b) => a + b, 0) / rels.length);
                const effs = hist.map(h => h.effectivePercent).filter(v => v != null);
                if (effs.length) avg.effectivePercent = Math.round(effs.reduce((a, b) => a + b, 0) / effs.length);
                const wastes = hist.map(h => h.wastedPercent).filter(v => v != null);
                if (wastes.length) avg.wastedPercent = Math.round(wastes.reduce((a, b) => a + b, 0) / wastes.length);
                // queueEndCounts: take the last available snapshot
                const lastQ = hist.slice().reverse().find(h => h.queueEndCounts);
                if (lastQ && lastQ.queueEndCounts) avg.queueEndCounts = lastQ.queueEndCounts;
                return avg;
            };

            const classical = avgFromHistory(perfRef.current.classic?.history || []);
            const intelligent = avgFromHistory(perfRef.current.intelligent?.history || []);

            const compare = (metric, lowerIsBetter = true) => {
                const a = classical && classical[metric] != null ? classical[metric] : null;
                const b = intelligent && intelligent[metric] != null ? intelligent[metric] : null;
                let winner = null;
                if (a == null && b == null) winner = null;
                else if (a == null) winner = 'intelligent';
                else if (b == null) winner = 'classic';
                else if (a === b) winner = 'tie';
                else if (lowerIsBetter) winner = (a < b) ? 'classic' : 'intelligent';
                else winner = (a > b) ? 'classic' : 'intelligent';
                return { classic: a, intelligent: b, winner };
            };

            const efficiencyComparison = {
                avgWait: compare('avgWaitSec', true),
                released: compare('released', false),
                effectiveGreenPercent: compare('effectivePercent', false),
                wastedGreenPercent: compare('wastedPercent', true),
                queueEndTotal: (() => {
                    const a = classical && classical.queueEndCounts ? Object.values(classical.queueEndCounts).reduce((x, y) => (x || 0) + (y || 0), 0) : null;
                    const b = intelligent && intelligent.queueEndCounts ? Object.values(intelligent.queueEndCounts).reduce((x, y) => (x || 0) + (y || 0), 0) : null;
                    let winner = null;
                    if (a == null && b == null) winner = null;
                    else if (a == null) winner = 'intelligent';
                    else if (b == null) winner = 'classic';
                    else if (a === b) winner = 'tie';
                    else winner = (a < b) ? 'classic' : 'intelligent';
                    return { classic: a, intelligent: b, winner };
                })()
            };

            // Compute red->green average and std (seconds) per mode from collected samples
            const computeRTG = (modeKey) => {
                try {
                    const s = redToGreenStatsRef.current && redToGreenStatsRef.current[modeKey] ? redToGreenStatsRef.current[modeKey] : { count: 0, totalMs: 0, sumSq: 0 };
                    if (!s || !s.count) return { avg: null, std: null };
                    const meanMs = s.totalMs / s.count;
                    const meanS = Math.round((meanMs / 1000) * 10) / 10;
                    const variance = Math.max(0, (s.sumSq / s.count) - (meanMs * meanMs));
                    const stdMs = Math.sqrt(variance);
                    const stdS = Math.round((stdMs / 1000) * 10) / 10;
                    return { avg: meanS, std: stdS };
                } catch (e) { return { avg: null, std: null }; }
            };

            const rtgClassic = computeRTG('classic');
            const rtgInt = computeRTG('intelligent');
            // winner: lower average is better (faster red->green)
            let rtgWinner = null;
            if (rtgClassic.avg == null && rtgInt.avg == null) rtgWinner = null;
            else if (rtgClassic.avg == null) rtgWinner = 'intelligent';
            else if (rtgInt.avg == null) rtgWinner = 'classic';
            else if (rtgClassic.avg === rtgInt.avg) rtgWinner = 'tie';
            else rtgWinner = (rtgClassic.avg < rtgInt.avg) ? 'classic' : 'intelligent';

            efficiencyComparison.redToGreenAvg = { classic: rtgClassic.avg, intelligent: rtgInt.avg, winner: rtgWinner };
            efficiencyComparison.redToGreenStd = { classic: rtgClassic.std, intelligent: rtgInt.std, winner: rtgWinner };

            // Fallbacks: only populate runtime-derived fallbacks for the active mode
            try {
                const effectiveMode = getEffectiveMode();

                // If we're in classic mode, prefer last-phase classic stats and use live measured counts
                if (effectiveMode === 'classic') {
                    if ((!efficiencyComparison.released.classic || efficiencyComparison.released.classic === null) && lastPhaseReleasedRef.current) {
                        efficiencyComparison.released.classic = lastPhaseReleasedRef.current.total || 0;
                    }
                    if ((!efficiencyComparison.effectiveGreenPercent.classic || efficiencyComparison.effectiveGreenPercent.classic === null) && perfRef.current.classic) {
                        const c = perfRef.current.classic;
                        const tot = (c.greenOpenWithVehicles || 0) + (c.greenOpenWasted || 0);
                        efficiencyComparison.effectiveGreenPercent.classic = tot > 0 ? Math.round((c.greenOpenWithVehicles / tot) * 100) : null;
                        efficiencyComparison.wastedGreenPercent.classic = tot > 0 ? Math.round((c.greenOpenWasted / tot) * 100) : null;
                    }
                    if (efficiencyComparison.queueEndTotal.classic == null) {
                        const last = lastMeasuredCountsRef.current || measureWaitingQueues();
                        efficiencyComparison.queueEndTotal.classic = last ? (Object.values(last).reduce((x, y) => (x || 0) + (y || 0), 0)) : 0;
                    }
                } else {
                    // In intelligent mode, populate intelligent fallbacks from perfRef and live counts
                    if ((!efficiencyComparison.released.intelligent || efficiencyComparison.released.intelligent === null)) {
                        let intelDelta = (typeof statsRef.current.totalReleased === 'number') ? (statsRef.current.totalReleased - (prevTotalReleasedRef.current || 0)) : (releasedSinceLastEvalRef.current || 0);
                        if (typeof intelDelta !== 'number' || intelDelta < 0) {
                            console.warn('[Perf] detected negative intelDelta when computing efficiencyComparison.released.intelligent. Clamping to 0. intelDelta=', intelDelta);
                            intelDelta = 0;
                            // advance prev marker to avoid repeated negatives
                            prevTotalReleasedRef.current = statsRef.current.totalReleased || prevTotalReleasedRef.current;
                        }
                        // compute accumulator-based released diff as fallback
                        let accReleased = null;
                        try {
                            const effInt = efficiencyStatsRef.current && efficiencyStatsRef.current.intelligent;
                            if (effInt && effInt.totalLiberados) {
                                accReleased = ((effInt.totalLiberados && effInt.totalLiberados.total) || 0) - (effInt.prevSnapshotTotalLiberados || 0);
                                if (typeof accReleased !== 'number' || accReleased < 0) accReleased = 0;
                            }
                        } catch (ee) { accReleased = null; }
                        const chosen = Math.max(0, Math.floor(intelDelta || 0), (accReleased != null ? Math.floor(accReleased) : -1));
                        efficiencyComparison.released.intelligent = chosen;
                    }
                    if ((!efficiencyComparison.effectiveGreenPercent.intelligent || efficiencyComparison.effectiveGreenPercent.intelligent === null) && perfRef.current.intelligent) {
                        const i = perfRef.current.intelligent;
                        const tot = (i.greenOpenWithVehicles || 0) + (i.greenOpenWasted || 0);
                        efficiencyComparison.effectiveGreenPercent.intelligent = tot > 0 ? Math.round((i.greenOpenWithVehicles / tot) * 100) : null;
                        efficiencyComparison.wastedGreenPercent.intelligent = tot > 0 ? Math.round((i.greenOpenWasted / tot) * 100) : null;
                    }
                    if (efficiencyComparison.queueEndTotal.intelligent == null) {
                        const last = lastMeasuredCountsRef.current || measureWaitingQueues();
                        efficiencyComparison.queueEndTotal.intelligent = last ? (Object.values(last).reduce((x, y) => (x || 0) + (y || 0), 0)) : 0;
                    }
                }
            } catch (e) { console.warn('efficiencyComparison fallback compute error', e); }

            // Additional fallbacks using persistent accumulators (efficiencyStatsRef)
            try {
                const effRef = efficiencyStatsRef.current || {};
                // Monotonic guard: ensure cumulative totals never decrease in the UI
                try {
                    ['classic', 'intelligent'].forEach(mode => {
                        const eff = effRef[mode];
                        if (!eff) return;
                        const cur = (eff.totalLiberados && eff.totalLiberados.total) || 0;
                        const last = lastKnownTotalsRef.current[mode] || 0;
                        if (cur < last) {
                            // Detected suspicious decrease; keep showing the last known (monotonic) value
                            try { pushDebug(`[Perf][WARN] ${mode} cumulative total decreased ${last} -> ${cur}. Clamping to ${last}`); } catch (e) { }
                            // Prevent UI from using a lower cumulative value
                            eff.totalLiberados.total = last;
                        } else {
                            lastKnownTotalsRef.current[mode] = cur;
                        }
                    });
                } catch (ee) {
                    console.warn('monotonic guard error', ee);
                }
                // Classic fallbacks
                if (effRef.classic) {
                    const c = effRef.classic;
                    // avg wait (ms -> sec)
                    const totalLibC = (c.totalLiberados && c.totalLiberados.total) || 0;
                    if ((!classical || classical.avgWaitSec == null) && totalLibC > 0) {
                        const totalWaitMs = (c.tiempoEsperaAcumulado.N || 0) + (c.tiempoEsperaAcumulado.S || 0) + (c.tiempoEsperaAcumulado.E || 0) + (c.tiempoEsperaAcumulado.W || 0);
                        const avgSec = Math.round(((totalWaitMs / totalLibC) / 1000) * 10) / 10;
                        if (!efficiencyComparison.avgWait.classic) efficiencyComparison.avgWait.classic = avgSec;
                        else if (efficiencyComparison.avgWait.classic == null) efficiencyComparison.avgWait.classic = avgSec;
                    }
                    // released by totals diff
                    if ((!efficiencyComparison.released.classic || efficiencyComparison.released.classic == null)) {
                        const releasedByDiff = (c.totalLiberados && c.totalLiberados.total) ? ((c.totalLiberados.total || 0) - (c.prevSnapshotTotalLiberados || 0)) : null;
                        if (typeof releasedByDiff === 'number' && releasedByDiff >= 0) efficiencyComparison.released.classic = releasedByDiff;
                    }
                    // queue end total
                    if (efficiencyComparison.queueEndTotal.classic == null && c.totalEnCola) {
                        efficiencyComparison.queueEndTotal.classic = Object.values(c.totalEnCola).reduce((x, y) => (x || 0) + (y || 0), 0);
                    }
                }
                // Intelligent fallbacks
                if (effRef.intelligent) {
                    const i = effRef.intelligent;
                    const totalLibI = (i.totalLiberados && i.totalLiberados.total) || 0;
                    if ((!intelligent || intelligent.avgWaitSec == null) && totalLibI > 0) {
                        const totalWaitMs = (i.tiempoEsperaAcumulado.N || 0) + (i.tiempoEsperaAcumulado.S || 0) + (i.tiempoEsperaAcumulado.E || 0) + (i.tiempoEsperaAcumulado.W || 0);
                        const avgSec = Math.round(((totalWaitMs / totalLibI) / 1000) * 10) / 10;
                        if (!efficiencyComparison.avgWait.intelligent) efficiencyComparison.avgWait.intelligent = avgSec;
                        else if (efficiencyComparison.avgWait.intelligent == null) efficiencyComparison.avgWait.intelligent = avgSec;
                    }
                    // Use cumulative totalLiberados for intelligent mode (show running sum)
                    try {
                        const totalLib = (i.totalLiberados && i.totalLiberados.total) || 0;
                        efficiencyComparison.released.intelligent = totalLib;
                    } catch (ee) { }
                    if (efficiencyComparison.queueEndTotal.intelligent == null && i.totalEnCola) {
                        efficiencyComparison.queueEndTotal.intelligent = Object.values(i.totalEnCola).reduce((x, y) => (x || 0) + (y || 0), 0);
                    }
                }
            } catch (e) { console.warn('efficiencyComparison accumulators fallback error', e); }

            setStats({
                waiting,
                active,
                totalReleased: statsRef.current.totalReleased,
                efficiency,
                totals: { ...releasedTotalsRef.current },
                lastPhase: { ...lastPhaseReleasedRef.current },
                rendered,
                metadata,
                efficiencyComparison
            });
        };

        // Fase inicial: fija NS para clásico, TODOS ROJOS para GreenWave
        if (trafficLightMode === 'classic') {
            currentPhaseRef.current = 'NS';
            setPhase('NS');
            updateTrafficLights(['N', 'S'], 'green');
        } else {
            // Modo GreenWave: TODOS LOS SEMÁFOROS EN ROJO al inicio
            currentPhaseRef.current = null;
            setPhase('NS');
            console.log('🔴 Iniciando GreenWave: TODOS los semáforos en ROJO');
            updateTrafficLights([], 'green');
        }
        adaptivePhaseTargetRef.current = { axis: currentPhaseRef.current, initialQueue: 0 };

        // ===== 11. MAIN LOOP =====
        let animationId;

        const animate = () => {
            animationId = requestAnimationFrame(animate);

            if (isRunning) {
                // Advance ticks according to fractional speed multiplier using an accumulator
                try {
                    const speedMul = Math.max(0.0001, (speedMultiplierRef.current || 1));
                    tickAccumulatorRef.current += speedMul;
                    const add = Math.floor(tickAccumulatorRef.current);
                    if (add > 0) {
                        tickRef.current += add;
                        tickAccumulatorRef.current -= add;
                    }
                } catch (e) {
                    tickRef.current++;
                }

                // Procesar petición de reset enviada desde la UI (botón)
                if (resetGreenWaveRequestRef.current) {
                    resetGreenWaveRequestRef.current = false;
                    try {
                        resetVehiclesStateForGreenWave();
                        // Reset explícito: poner en rojo para recalibrar
                        try { pushDebug('[GreenWave] reset requested'); } catch (e) { _noop(e); }
                        updateTrafficLights([], 'green');
                        const instantWaiting = measureWaitingQueues();
                        try { pushDebug('[GreenWave] resetRequested -> instantWaiting = ' + JSON.stringify(instantWaiting)); } catch (e) { _noop(e); }
                        if (!accidentRef.current.active) {
                            console.debug('[GreenWave] Applying dynamic logic immediately after reset');
                            applyGreenWaveDynamicLogic(instantWaiting);
                        }
                    } catch (err) {
                        console.warn('Error al procesar resetGreenWaveRequest:', err);
                    }
                }

                // Read the live mode from the ref to avoid stale closure values
                const effectiveMode = getEffectiveMode();
                const isClassic = effectiveMode === 'classic';

                // Reinicio limpio al cambiar de modo
                if (effectiveMode !== lastModeRef.current) {
                    if (isClassic) {
                        currentPhaseRef.current = 'NS';
                        setPhase('NS');
                        updateTrafficLights(['N', 'S'], 'green');
                        const timer = phaseTimerRef.current;
                        timer.remaining = CLASSIC_PHASE_SECONDS;
                        timer.lastUpdate = performance.now();
                        adaptivePhaseTargetRef.current = { axis: 'NS', initialQueue: 0 };
                    } else {
                        // Entra a GreenWave: SOLO la primera vez en rojo para calibrar
                        const isFirstTimeIntelligent = !intelligentModeInitializedRef.current;
                        if (isFirstTimeIntelligent) {
                            console.log('🔴 Calibrando GreenWave: TODOS en ROJO inicial');
                            intelligentModeInitializedRef.current = true;
                        }
                        const timer = phaseTimerRef.current;
                        timer.remaining = 0;
                        timer.lastUpdate = performance.now();

                        currentPhaseRef.current = null; // Sin fase fija
                        setPhase('NS'); // UI placeholder
                        adaptivePhaseTargetRef.current = { axis: null, initialQueue: 0 };

                        // Resetear estado de vehículos para evaluar desde cero
                        resetVehiclesStateForGreenWave();
                        // SOLO poner en rojo la primera vez que entra
                        if (isFirstTimeIntelligent) {
                            updateTrafficLights([], 'green');
                        }

                        // Aplicar lógica inmediatamente si hay vehículos en cola
                        const instantWaiting = measureWaitingQueues();
                        console.debug('[GreenWave] onModeChange -> instantWaiting =', instantWaiting);
                        if (!(accidentRef.current.active)) {
                            console.debug('[GreenWave] onModeChange: calling applyGreenWaveDynamicLogic');
                            applyGreenWaveDynamicLogic(instantWaiting);
                            try { renderModeDisplays(lastMeasuredCountsRef.current || instantWaiting); } catch (e) { }
                            try { renderArrowInfo(lastMeasuredCountsRef.current || instantWaiting); } catch (e) { }
                            // Also snapshot intelligent perf on immediate on-mode change evaluation
                            try {
                                const intel = perfRef.current.intelligent;
                                const waitArr = intel.waitTimes || [];
                                const avgWaitMs = waitArr.length ? (waitArr.reduce((a, b) => a + b, 0) / waitArr.length) : null;
                                let released = (typeof statsRef.current.totalReleased === 'number')
                                    ? (statsRef.current.totalReleased - (prevTotalReleasedRef.current || 0))
                                    : (releasedSinceLastEvalRef.current || 0);
                                if (typeof released !== 'number' || released < 0) {
                                    console.warn('[Perf] detected negative released delta on mode-change snapshot. Clamping to 0. released=', released);
                                    released = 0;
                                }
                                // advance prev snapshot marker to current total (avoid repeated negatives)
                                prevTotalReleasedRef.current = statsRef.current.totalReleased || prevTotalReleasedRef.current;
                                const greenWith = intel.greenOpenWithVehicles || 0;
                                const greenWasted = intel.greenOpenWasted || 0;
                                const totalGreen = greenWith + greenWasted;
                                const effectivePercent = totalGreen > 0 ? Math.round((greenWith / totalGreen) * 100) : null;
                                const wastedPercent = totalGreen > 0 ? Math.round((greenWasted / totalGreen) * 100) : null;
                                intel.lastCycle = {
                                    avgWaitSec: avgWaitMs != null ? Math.round((avgWaitMs / 1000) * 10) / 10 : null,
                                    released,
                                    effectivePercent,
                                    wastedPercent,
                                    queueEndCounts: lastMeasuredCountsRef.current || instantWaiting
                                };
                                try {
                                    intel.history = intel.history || [];
                                    intel.history.push(intel.lastCycle);
                                    if (intel.history.length > 6) intel.history.shift();
                                    console.debug('[Perf] intelligent immediate snapshot', intel.lastCycle);
                                } catch (e) { }
                                releasedSinceLastEvalRef.current = 0;
                                perfRef.current.intelligent.waitTimes = [];
                                perfRef.current.intelligent.greenOpenWithVehicles = 0;
                                perfRef.current.intelligent.greenOpenWasted = 0;
                                // Update persistent efficiency accumulators for intelligent mode
                                try {
                                    const effInt = efficiencyStatsRef.current.intelligent;
                                    if (effInt) {
                                        // Accumulate end-of-cycle queue counts for intelligent mode (do not overwrite)
                                        try {
                                            const q = intel.lastCycle.queueEndCounts || (lastMeasuredCountsRef.current || instantWaiting) || { N: 0, S: 0, E: 0, W: 0 };
                                            ['N', 'S', 'E', 'W'].forEach(d => {
                                                effInt.totalEnCola[d] = (effInt.totalEnCola[d] || 0) + (q[d] || 0);
                                            });
                                            effInt.totalEnCola.total = Object.values(effInt.totalEnCola).reduce((x, y) => (x || 0) + (y || 0), 0);
                                        } catch (ee) { console.warn('accumulate intelligent totalEnCola error', ee); }
                                        const currentTotalLiberados = (effInt.totalLiberados && effInt.totalLiberados.total) || 0;
                                        let releasedByDiff = currentTotalLiberados - (effInt.prevSnapshotTotalLiberados || 0);
                                        if (typeof releasedByDiff !== 'number' || releasedByDiff < 0) {
                                            // Defensive: never report negative released counts. If we detect a negative
                                            // delta it likely means snapshots/ordering produced inconsistent markers.
                                            console.warn('[Perf] detected negative releasedByDiff (intelligent). Clamping to 0. currentTotalLiberados=', currentTotalLiberados, 'prev=', effInt.prevSnapshotTotalLiberados);
                                            releasedByDiff = 0;
                                            // Advance prev marker to current to avoid repeated negative deltas
                                            effInt.prevSnapshotTotalLiberados = currentTotalLiberados;
                                        } else {
                                            intel.lastCycle.released = releasedByDiff || intel.lastCycle.released;
                                            effInt.prevSnapshotTotalLiberados = currentTotalLiberados;
                                        }
                                        console.debug('[Perf][SNAP_IMMEDIATE] intelligent snapshot releasedByDiff=', releasedByDiff, 'currentTotalLiberados=', currentTotalLiberados, 'prev=', effInt.prevSnapshotTotalLiberados);
                                        try { pushDebug(`[Perf][SNAP_IMMEDIATE] released=${releasedByDiff} totalLiberados=${currentTotalLiberados} prev=${effInt.prevSnapshotTotalLiberados}`); } catch (e) { }
                                    }
                                } catch (e) { }
                            } catch (e) { console.warn('snapshot intelligent perf error', e); }
                        }
                    }
                    lastModeRef.current = effectiveMode;
                }

                // ===== PROCESAMIENTO SOLO EN MODO CLÁSICO =====
                if (isClassic) {
                    const timer = phaseTimerRef.current;
                    const now = performance.now();
                    const deltaSec = (now - timer.lastUpdate) / 1000;
                    timer.lastUpdate = now;
                    const speedFactor = speedMultiplierRef.current || 1;

                    const phaseState = classicPhaseStateRef.current;
                    const { active: accidentActive } = accidentRef.current;

                    // Si hay accidente, todos en rojo
                    if (accidentActive) {
                        updateTrafficLights([], 'red');
                    } else {
                        // Decrementar el temporizador principal
                        timer.remaining = Math.max(0, timer.remaining - (deltaSec * speedFactor));

                        // Máquina de estados para transiciones de fase
                        if (phaseState.phaseState === 'green') {
                            // Está en VERDE
                            const activeDirections = phaseState.currentPhase === 'NS' ? ['N', 'S'] : ['E', 'W'];
                            const inYellow = timer.remaining <= CLASSIC_YELLOW_SECONDS;

                            if (inYellow) {
                                // Últimos 3 segundos: mostrar AMARILLO en la fase activa
                                updateTrafficLights(activeDirections, 'yellow');
                            } else {
                                // Mostrar VERDE en la fase activa
                                updateTrafficLights(activeDirections, 'green');
                            }

                            // Si termina la fase verde, pasar a transición
                            if (timer.remaining <= 0) {
                                // Snapshot classic-mode metrics for the phase that just ended
                                try {
                                    const classic = perfRef.current.classic;
                                    const waitArr = classic.waitTimes || [];
                                    const avgWaitMs = waitArr.length ? (waitArr.reduce((a, b) => a + b, 0) / waitArr.length) : null;
                                    const released = (lastPhaseReleasedRef.current && lastPhaseReleasedRef.current.total) || 0;
                                    const greenWith = classic.greenOpenWithVehicles || 0;
                                    const greenWasted = classic.greenOpenWasted || 0;
                                    const totalGreen = greenWith + greenWasted;
                                    const effectivePercent = totalGreen > 0 ? Math.round((greenWith / totalGreen) * 100) : null;
                                    const wastedPercent = totalGreen > 0 ? Math.round((greenWasted / totalGreen) * 100) : null;
                                    const queueEnd = measureWaitingQueues();
                                    classic.lastCycle = {
                                        avgWaitSec: avgWaitMs != null ? Math.round((avgWaitMs / 1000) * 10) / 10 : null,
                                        released,
                                        effectivePercent,
                                        wastedPercent,
                                        queueEndCounts: queueEnd
                                    };
                                    try {
                                        const cl = perfRef.current.classic;
                                        cl.history = cl.history || [];
                                        cl.history.push(classic.lastCycle);
                                        if (cl.history.length > 6) cl.history.shift();
                                        console.debug('[Perf] classic snapshot', classic.lastCycle);
                                    } catch (e) { }
                                    // Update persistent efficiency accumulators for classic mode
                                    try {
                                        const effClassic = efficiencyStatsRef.current.classic;
                                        if (effClassic) {
                                            try {
                                                const q = queueEnd || { N: 0, S: 0, E: 0, W: 0 };
                                                ['N', 'S', 'E', 'W'].forEach(d => {
                                                    effClassic.totalEnCola[d] = (effClassic.totalEnCola[d] || 0) + (q[d] || 0);
                                                });
                                                effClassic.totalEnCola.total = Object.values(effClassic.totalEnCola).reduce((x, y) => (x || 0) + (y || 0), 0);
                                            } catch (ee) { console.warn('accumulate classic totalEnCola error', ee); }
                                            const currentTotalLiberados = (effClassic.totalLiberados && effClassic.totalLiberados.total) || 0;
                                            let releasedByDiff = currentTotalLiberados - (effClassic.prevSnapshotTotalLiberados || 0);
                                            if (typeof releasedByDiff !== 'number' || releasedByDiff < 0) {
                                                releasedByDiff = 0;
                                                effClassic.prevSnapshotTotalLiberados = currentTotalLiberados;
                                            } else {
                                                classic.lastCycle.released = releasedByDiff || classic.lastCycle.released;
                                                effClassic.prevSnapshotTotalLiberados = currentTotalLiberados;
                                            }
                                        }
                                    } catch (e) { }
                                    perfRef.current.classic.waitTimes = [];
                                    perfRef.current.classic.greenOpenWithVehicles = 0;
                                    perfRef.current.classic.greenOpenWasted = 0;
                                } catch (e) { console.warn('snapshot classic perf error', e); }

                                // TRANSICIÓN: Cambiar a AMARILLO para todos (preparar cambio de fase)
                                phaseState.phaseState = 'yellow';
                                phaseState.yellowStartTime = now;
                                updateTrafficLights([], 'yellow'); // Todos en amarillo (transición)
                            }
                        } else if (phaseState.phaseState === 'yellow') {
                            // Está en AMARILLO (fase de transición)
                            const yellowElapsed = now - phaseState.yellowStartTime;

                            if (yellowElapsed >= phaseState.yellowDuration) {
                                // Transición completada: cambiar a la nueva fase
                                phaseState.currentPhase = phaseState.currentPhase === 'NS' ? 'EW' : 'NS';
                                phaseState.phaseState = 'green'; // Pasar a verde

                                currentPhaseRef.current = phaseState.currentPhase;
                                setPhase(phaseState.currentPhase);
                                adaptivePhaseTargetRef.current = { axis: phaseState.currentPhase, initialQueue: 0 };

                                // Reiniciar timer con 60 segundos completos
                                timer.remaining = CLASSIC_PHASE_SECONDS;
                                timer.lastUpdate = now;

                                const nextDirections = phaseState.currentPhase === 'NS' ? ['N', 'S'] : ['E', 'W'];
                                updateTrafficLights(nextDirections, 'green');
                            } else {
                                // Seguir en amarillo
                                updateTrafficLights([], 'yellow');
                            }
                        }
                    }
                }
                // GreenWave™ (intelligent mode): COMPLETAMENTE SIN TIMER - solo colas

                // Recuento de vehículos en cola por dirección (entrada y antes de cruce)
                const waitingCounts = measureWaitingQueues();

                // ===== GESTIÓN DE VISUALIZACIÓN DE ACCIDENTES =====
                const { active: accidentActive, location: accidentLocation } = accidentRef.current;
                if (accidentActive && accidentLocation) {
                    if (!accidentMeshes[accidentLocation]) {
                        createAccidentMesh(accidentLocation);
                    }
                    // Pulsación visual del accidente
                    if (accidentMeshes[accidentLocation]) {
                        const pulse = Math.sin(tickRef.current * 0.1) * 0.3 + 0.7;
                        accidentMeshes[accidentLocation].material.emissiveIntensity = pulse;
                    }
                } else {
                    // Limpiar visualización de accidente
                    Object.keys(accidentMeshes).forEach(dir => {
                        if (accidentMeshes[dir]) {
                            scene.remove(accidentMeshes[dir]);
                            accidentMeshes[dir].geometry?.dispose();
                            accidentMeshes[dir].material?.dispose();
                            accidentMeshes[dir] = null;
                        }
                    });
                    // remove temporary mode markers if present when not in GreenWave
                    try {
                        const markers = scene.userData?.modeMarkers;
                        if (markers) {
                            Object.keys(markers).forEach(k => {
                                const m = markers[k];
                                if (m) {
                                    scene.remove(m);
                                    m.geometry?.dispose();
                                    m.material?.dispose();
                                }
                            });
                            scene.userData.modeMarkers = {};
                        }
                    } catch (err) {
                        // ignore
                    }
                }

                // HUD de modo (temporizador / colas / estado)
                renderModeDisplays(waitingCounts);
                // Arrow info above the chosen semaphore (timer in classic, queued in GreenWave)
                try { renderArrowInfo(waitingCounts); } catch (err) { console.warn('renderArrowInfo error', err); }

                // ===== GENERACIÓN DE VEHÍCULOS CONTROLADA POR NIVEL DE TRÁFICO =====
                // Usar dynamicTrafficLevel para controlar spawn según hora y nivel
                const spawnParams = getSpawnParamsByLevel(dynamicTrafficLevel);
                if (tickRef.current % spawnParams.spawnInterval === 0) {
                    const rates = getCurrentRates();
                    const totalRate = rates.N + rates.S + rates.E + rates.W;

                    // Multiplicador baseado en nivel de tráfico
                    const spawnChance = Math.min(0.95, (totalRate * 0.08) * spawnParams.spawnChanceMultiplier);

                    if (Math.random() < spawnChance) {
                        const dir = pickDirection(rates);

                        // Verificar que no excedamos el máximo de vehículos en ese carril
                        const vehiclesInLane = vehiclesRef.current[dir].length;
                        if (vehiclesInLane < spawnParams.maxVehiclesPerLane) {
                            spawnVehicle(dir);
                        }
                    }

                    // If a test is forcing a mode, boost spawn to ensure traffic for the measurement
                    try {
                        if (testForceModeRef.current) {
                            ['N', 'S', 'E', 'W'].forEach(d => {
                                const vehiclesInLane = vehiclesRef.current[d].length;
                                if (vehiclesInLane < spawnParams.maxVehiclesPerLane) {
                                    try { spawnVehicle(d); } catch (e) { _noop(e); }
                                }
                            });
                        }
                    } catch (e) { _noop(e); }
                }

                // ===== GREENWAVE™ DYNAMIC MODE LOGIC =====
                // Solo ejecutar en modo inteligente/greenwave, NO en clásico
                if (effectiveMode !== 'classic') {
                    // MANEJO DE ACCIDENTES EN MODO GREENWAVE
                    // Durante un accidente, el sistema debe detener TODOS los semáforos (modo seguro)
                    if (accidentRef.current.active) {
                        updateTrafficLights([], 'green'); // fuerza TODOS en rojo
                    } else {
                        // ===== MANEJO DE TRANSICIÓN AMARILLA EN MODO INTELIGENTE =====
                        // Si estamos en transición amarilla, esperar 3 segundos y luego pasar a verde
                        if (intelligentYellowStateRef.current.isTransitioning) {
                            const yellowState = intelligentYellowStateRef.current;
                            const now = performance.now();
                            const yellowElapsed = now - yellowState.yellowStartTime;
                            const YELLOW_DURATION_MS = 3000; // 3 segundos

                            if (yellowElapsed >= YELLOW_DURATION_MS) {
                                // Transición completada: pasar a VERDE
                                yellowState.isTransitioning = false;
                                const greenDirs = yellowState.nextGreenDirs;
                                console.debug('[GreenWave] Transición AMARILLA completada, pasando a VERDE:', greenDirs);
                                try { updateTrafficLights(greenDirs, 'green'); } catch (e) { _noop(e); }
                            }
                            // Seguir en amarillo, no ejecutar lógica de evaluación
                        } else {
                            // SIN ACCIDENTE y SIN TRANSICIÓN: aplicar lógica GreenWave™ periódicamente.
                            // La frecuencia de evaluación se escala por el multiplicador de velocidad
                            // para que los cambios de velocidad también aceleren/ralenticen las decisiones.
                            const speedFactor = speedMultiplierRef.current || 1;
                            // Base interval: 30 ticks (~0.5s). Divide por speedFactor to evaluate more often when vehicles are faster.
                            const evalInterval = Math.max(4, Math.round(30 / speedFactor));
                            if (tickRef.current % evalInterval === 0) {
                                console.debug('[GreenWave] periodic eval tick -> waitingCounts =', waitingCounts, 'evalInterval=', evalInterval);
                                applyGreenWaveDynamicLogic(waitingCounts);
                                try { renderModeDisplays(lastMeasuredCountsRef.current || waitingCounts); } catch (e) { }
                                try { renderArrowInfo(lastMeasuredCountsRef.current || waitingCounts); } catch (e) { }
                                // Snapshot performance metrics for the intelligent mode (per evaluation cycle)
                                try {
                                    const intel = perfRef.current.intelligent;
                                    const waitArr = intel.waitTimes || [];
                                    const avgWaitMs = waitArr.length ? (waitArr.reduce((a, b) => a + b, 0) / waitArr.length) : null;
                                    let released = (typeof statsRef.current.totalReleased === 'number')
                                        ? (statsRef.current.totalReleased - (prevTotalReleasedRef.current || 0))
                                        : (releasedSinceLastEvalRef.current || 0);
                                    if (typeof released !== 'number' || released < 0) {
                                        console.warn('[Perf] detected negative released delta during periodic snapshot. Clamping to 0. released=', released);
                                        released = 0;
                                    }
                                    console.debug('[Perf][SNAP_PERIODIC_STATS] stats.totalReleased=', statsRef.current.totalReleased, 'prevTotalReleasedRef=', prevTotalReleasedRef.current, 'releasedDelta=', released);
                                    try { pushDebug(`[Perf][SNAP_PERIODIC_STATS] statsTotal=${statsRef.current.totalReleased} prev=${prevTotalReleasedRef.current} delta=${released}`); } catch (e) { }
                                    // advance prev snapshot marker to current total to avoid repeated negatives
                                    prevTotalReleasedRef.current = statsRef.current.totalReleased || prevTotalReleasedRef.current;
                                    const greenWith = intel.greenOpenWithVehicles || 0;
                                    const greenWasted = intel.greenOpenWasted || 0;
                                    const totalGreen = greenWith + greenWasted;
                                    const effectivePercent = totalGreen > 0 ? Math.round((greenWith / totalGreen) * 100) : null;
                                    const wastedPercent = totalGreen > 0 ? Math.round((greenWasted / totalGreen) * 100) : null;
                                    intel.lastCycle = {
                                        avgWaitSec: avgWaitMs != null ? Math.round((avgWaitMs / 1000) * 10) / 10 : null,
                                        released,
                                        effectivePercent,
                                        wastedPercent,
                                        queueEndCounts: lastMeasuredCountsRef.current || waitingCounts
                                    };
                                    // push into history and reset window counters
                                    try {
                                        intel.history = intel.history || [];
                                        intel.history.push(intel.lastCycle);
                                        if (intel.history.length > 6) intel.history.shift();
                                        console.debug('[Perf] intelligent periodic snapshot', intel.lastCycle);
                                    } catch (e) { }
                                    releasedSinceLastEvalRef.current = 0;
                                    perfRef.current.intelligent.waitTimes = [];
                                    perfRef.current.intelligent.greenOpenWithVehicles = 0;
                                    perfRef.current.intelligent.greenOpenWasted = 0;
                                    // Persist intelligent snapshot into accumulators
                                    try {
                                        const effInt = efficiencyStatsRef.current.intelligent;
                                        if (effInt) {
                                            try {
                                                const q = intel.lastCycle.queueEndCounts || (lastMeasuredCountsRef.current || waitingCounts) || { N: 0, S: 0, E: 0, W: 0 };
                                                ['N', 'S', 'E', 'W'].forEach(d => {
                                                    effInt.totalEnCola[d] = (effInt.totalEnCola[d] || 0) + (q[d] || 0);
                                                });
                                                effInt.totalEnCola.total = Object.values(effInt.totalEnCola).reduce((x, y) => (x || 0) + (y || 0), 0);
                                            } catch (ee) { console.warn('accumulate intelligent periodic totalEnCola error', ee); }
                                            const currentTotalLiberados = (effInt.totalLiberados && effInt.totalLiberados.total) || 0;
                                            let releasedByDiff = currentTotalLiberados - (effInt.prevSnapshotTotalLiberados || 0);
                                            if (typeof releasedByDiff !== 'number' || releasedByDiff < 0) {
                                                console.warn('[Perf] detected negative releasedByDiff (intelligent periodic). Clamping to 0. currentTotalLiberados=', currentTotalLiberados, 'prev=', effInt.prevSnapshotTotalLiberados);
                                                releasedByDiff = 0;
                                                effInt.prevSnapshotTotalLiberados = currentTotalLiberados;
                                            } else {
                                                intel.lastCycle.released = releasedByDiff || intel.lastCycle.released;
                                                effInt.prevSnapshotTotalLiberados = currentTotalLiberados;
                                            }
                                            console.debug('[Perf][SNAP_PERIODIC] intelligent snapshot releasedByDiff=', releasedByDiff, 'currentTotalLiberados=', currentTotalLiberados, 'prev=', effInt.prevSnapshotTotalLiberados);
                                            try { pushDebug(`[Perf][SNAP_PERIODIC] released=${releasedByDiff} totalLiberados=${currentTotalLiberados} prev=${effInt.prevSnapshotTotalLiberados}`); } catch (e) { }
                                        }
                                    } catch (e) { }
                                } catch (e) { console.warn('snapshot intelligent perf error', e); }
                            }
                        }
                    }
                }

                updateVehicles();
                updateStatsDisplay(); // Actualizar estadísticas y metadatos en tiempo real
            }

            // DEBUG: force show an arrow every frame if debug flag enabled (helps verify rendering)
            try {
                if (debugForceShowArrowsRef.current) {
                    const phase = currentPhaseRef.current || lastPriorityAxisRef.current || 'NS';
                    const chosen = phase === 'NS' ? 'N' : 'E';
                    setEvaluationArrows([chosen]);
                }
            } catch (err) {
                console.warn('debug force show arrows error', err);
            }

            controls.update();
            renderer.render(scene, camera);
        };

        animate();

        // ===== RESIZE =====
        const handleResize = () => {
            if (!mount) return;
            camera.aspect = mount.clientWidth / mount.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(mount.clientWidth, mount.clientHeight);
        };
        window.addEventListener('resize', handleResize);

        // ===== CLEANUP =====
        return () => {
            window.removeEventListener('resize', handleResize);
            cancelAnimationFrame(animationId);

            ['N', 'S', 'E', 'W'].forEach(dir => {
                vehicles[dir].forEach(v => {
                    scene.remove(v);
                    v.geometry?.dispose();
                    v.material?.dispose();
                });
            });

            scene.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => {
                            if (m.map) m.map.dispose();
                            m.dispose();
                        });
                    } else {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                }
            });

            renderer.dispose();
            if (mount && renderer.domElement) {
                mount.removeChild(renderer.domElement);
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    return (
        <div className="relative w-full h-screen bg-black">
            {/* Canvas Three.js */}
            <div ref={mountRef} className="w-full h-full" />

            {/* Debug modal (centered) - toggled from top banner button */}
            {showDebugPanel && (
                <div className="fixed inset-0 z-50 flex items-center justify-center">
                    <div className="absolute inset-0 bg-black/70" onClick={() => setShowDebugPanel(false)} />
                    <div className="relative bg-black/95 text-xs text-cyan-100 p-4 rounded-lg border border-cyan-500/30 shadow-2xl w-2/5 max-w-3xl max-h-[75vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-3">
                            <div className="text-sm font-bold text-cyan-300">Debug</div>
                            <button onClick={() => setShowDebugPanel(false)} className="text-cyan-200 hover:text-cyan-100 px-2 py-1">✕</button>
                        </div>

                        {/* Vehicle Counting Diagnostic */}
                        <div className="mb-4 p-3 bg-black/50 border border-yellow-600/50 rounded text-[11px]">
                            <div className="font-bold text-yellow-400 mb-2">📊 DIAGNÓSTICO DE CONTEO DE VEHÍCULOS:</div>
                            <div className="space-y-1 font-mono text-yellow-300">
                                {['N', 'S', 'E', 'W'].map(dir => {
                                    const arr = vehiclesRef.current[dir] || [];
                                    const spawned = arr.length;
                                    const queued = arr.filter(v => v.userData.queueTriggered && !v.userData.exitTriggered && !v.userData.released).length;
                                    const exited = arr.filter(v => v.userData.exitTriggered).length;
                                    const released = arr.filter(v => v.userData.released).length;
                                    return (
                                        <div key={dir} className="leading-tight">
                                            <strong>{dir}:</strong> Spawned={spawned} | En Cola={queued} | Salieron={exited} | Released={released}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        <div className="font-mono text-[12px] space-y-1">
                            {debugLogs.length === 0 ? (
                                <div className="text-cyan-400/60">Sin logs</div>
                            ) : (
                                debugLogs.map((l, i) => (
                                    <div key={i} className="leading-tight break-words">{l}</div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            )}

            {/* Test runner modal */}
            {showTestModal && (
                <div className="fixed inset-0 z-[9999] flex items-center justify-center">
                    <div className="absolute inset-0 bg-black/70" onClick={() => { if (!testRunning) setShowTestModal(false); }} />
                    <div className="relative bg-black/95 text-sm text-cyan-100 p-6 rounded-lg border border-cyan-500/30 shadow-2xl w-[96%] max-w-[1400px] max-h-[92vh] overflow-y-auto">
                        <div className="flex items-center justify-between mb-3">
                            <div className="text-sm font-bold text-cyan-300">Comparar modos - Pruebas automáticas</div>
                            <button onClick={() => { if (!testRunning) setShowTestModal(false); }} className="text-cyan-200 hover:text-cyan-100 px-2 py-1">✕</button>
                        </div>
                        <div className="mb-3">
                            <label className="text-[12px] text-cyan-300">Duración por modo (segundos)</label>
                            <input type="number" min={5} max={300} value={testDurationSec} onChange={e => setTestDurationSec(Math.max(5, Math.min(300, Number(e.target.value) || 15)))} className="w-24 ml-2 bg-black/80 border border-cyan-600/30 rounded px-2 py-1 text-cyan-100" />
                            <label className="text-[12px] text-cyan-300 ml-4">Seed por dirección</label>
                            <input type="number" min={0} max={20} value={testSeedCount} onChange={e => setTestSeedCount(Math.max(0, Math.min(20, Number(e.target.value) || 0)))} className="w-16 ml-2 bg-black/80 border border-cyan-600/30 rounded px-2 py-1 text-cyan-100" />
                        </div>
                        <div className="flex gap-2 items-center">
                            <button disabled={testRunning} onClick={async () => {
                                if (testRunning) return;
                                setTestRunning(true);
                                setTestResults(null);
                                try { setTestInternalStatus({ warmup: 'Preparando warm-up', mode: 'Inicializando pruebas', info: 'Configurando condiciones extremas y reseteos' }); } catch (e) { _noop(e); }
                                try {
                                    try { pushDebug('[TestRunner] Iniciando pruebas...'); } catch (e) { }
                                    // Prefer calling via actionsRef to ensure correct binding
                                    const runner = actionsRef.current && actionsRef.current.runModeComparisonTests ? actionsRef.current.runModeComparisonTests : runModeComparisonTests;
                                    if (!runner) {
                                        const msg = 'TestRunner function not available';
                                        console.warn(msg);
                                        try { pushDebug(`[TestRunner][ERROR] ${msg}`); } catch (e) { }
                                        setTestRunning(false);
                                        return;
                                    }
                                    const results = await runner(testDurationSec);
                                    try { pushDebug('[TestRunner] Pruebas completadas'); } catch (e) { }
                                    setTestResults(results);
                                } catch (err) {
                                    console.warn('runModeComparisonTests error', err);
                                    try { pushDebug(`TestRunner error: ${err?.message || err}`); } catch (e) { }
                                }
                                setTestRunning(false);
                            }} className="px-3 py-2 bg-cyan-600/60 rounded border border-cyan-500/30">{testRunning ? 'Ejecutando...' : 'Iniciar pruebas'}</button>
                            <div className="text-[12px] text-cyan-300">Resultados:</div>
                        </div>
                        <div className="mt-3 grid grid-cols-1 md:grid-cols-3 gap-2 text-[12px]">
                            <div className="bg-black/70 border border-cyan-700/60 rounded px-3 py-2 text-cyan-100">
                                <div className="text-cyan-300 font-semibold mb-1">Warm-up</div>
                                <div className="leading-tight break-words">{testInternalStatus?.warmup || '—'}</div>
                            </div>
                            <div className="bg-black/70 border border-cyan-700/60 rounded px-3 py-2 text-cyan-100">
                                <div className="text-cyan-300 font-semibold mb-1">Modo</div>
                                <div className="leading-tight break-words">{testInternalStatus?.mode || '—'}</div>
                            </div>
                            <div className="bg-black/70 border border-cyan-700/60 rounded px-3 py-2 text-cyan-100">
                                <div className="text-cyan-300 font-semibold mb-1">Interno</div>
                                <div className="leading-tight break-words">{testInternalStatus?.info || '—'}</div>
                            </div>
                        </div>
                        <div className="mt-3 max-h-80 overflow-y-auto font-mono text-[12px]">
                            {/* Live counters while test runs */}
                            {testRunning && testCurrentMode && (
                                <div className="mb-2 px-3 py-2 rounded bg-black/70 border border-cyan-700 text-cyan-200">
                                    <div className="flex items-center justify-between text-xs text-cyan-300">
                                        <div>Ejecutando modo: <span className="font-bold text-cyan-100">{testCurrentMode}</span></div>
                                        <div className="font-mono">{testModeProgress}%</div>
                                    </div>
                                    <div className="w-full bg-cyan-900/10 h-2 mt-2 rounded">
                                        <div className="rounded" style={{ width: `${testModeProgress}%`, height: '100%', background: '#00e9fa' }} />
                                    </div>
                                </div>
                            )}
                            {testRunning && (
                                <div className="mb-2 px-3 py-2 rounded bg-black/70 border border-cyan-700 text-cyan-200">
                                    <div className="text-sm font-bold text-cyan-300 mb-2">📊 Vehículos que SALIERON durante la prueba (acumulado):</div>
                                    <div className="flex gap-6 text-sm">
                                        <div className="flex items-center gap-2">
                                            <span className="px-2 py-1 bg-cyan-800/40 rounded">🚗 Clásico:</span>
                                            <span className="font-mono text-lg text-cyan-100">{liveExitCounts.classic} vehículos</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <span className="px-2 py-1 bg-green-800/40 rounded">🚗 Inteligente:</span>
                                            <span className="font-mono text-lg text-green-200">{liveExitCounts.intelligent} vehículos</span>
                                        </div>
                                    </div>
                                    {liveRecentExits.length > 0 && (
                                        <div className="mt-2 text-xs text-cyan-400">Últimas salidas: {liveRecentExits.slice(0, 5).map(x => `${x.mode[0].toUpperCase()}:${x.dir}`).join(' , ')}</div>
                                    )}
                                </div>
                            )}
                            {testResults ? (
                                <div>
                                    <div className="mb-3 flex items-center justify-between">
                                        <div className="text-sm font-bold text-cyan-300">📊 Resultados comparativos (Prueba de {testDurationSec}s por modo)</div>
                                        <div className="flex items-center gap-3">
                                            <div className="text-xs text-cyan-200">🏆 Ganador:</div>
                                            <div className="px-3 py-1 rounded-full text-[13px] font-bold" style={{ background: testResults.winner === 'intelligent' ? '#064e3b' : (testResults.winner === 'classic' ? '#083344' : '#7c2d12'), color: '#e6fff6' }}>
                                                {testResults.winner ? testResults.winner.toUpperCase() : '—'}
                                            </div>
                                        </div>
                                    </div>

                                    <div className="mb-3 bg-black/50 border border-cyan-700/40 rounded px-3 py-2 text-xs text-cyan-200">
                                        <div className="text-cyan-300 font-bold mb-2">📖 Interpretación de las métricas:</div>
                                        <ul className="space-y-1 ml-2">
                                            <li>📤 <strong>Total vehículos que SALIERON:</strong> Cuántos autos lograron cruzar la intersección completa (meta: MÁS ES MEJOR)</li>
                                            <li>📥 <strong>Vehículos en COLA al final:</strong> Autos que quedan esperando en la intersección (meta: MENOS ES MEJOR)</li>
                                            <li>⏱️ <strong>Tiempo de espera promedio:</strong> Promedio de segundos que cada auto espera en la intersección (meta: MENOS ES MEJOR)</li>
                                        </ul>
                                    </div>

                                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-4" style={{ gridTemplateColumns: '70% 30%' }}>
                                        <div className="bg-black/80 p-3 rounded text-sm text-cyan-200 relative z-0 overflow-hidden">
                                            <canvas ref={comparisonCanvasRef} className="w-full" style={{ width: '100%', height: '420px', background: '#071014', display: 'block' }} />
                                        </div>
                                        <div className="bg-black p-4 rounded text-sm text-cyan-200 overflow-x-auto relative z-10">
                                            <table className="w-full text-left border-separate" style={{ borderSpacing: '0 8px' }}>
                                                <thead>
                                                    <tr className="border-b border-cyan-700/60">
                                                        <th className="text-xs text-cyan-300 font-semibold p-2">Métrica / Definición</th>
                                                        <th className="text-xs text-cyan-300 font-semibold p-2 text-center">🚗 Modo Clásico</th>
                                                        <th className="text-xs text-cyan-300 font-semibold p-2 text-center">🚗 GreenWave</th>
                                                        <th className="text-xs text-cyan-300 font-semibold p-2 text-center">Mejora %</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {(() => {
                                                        const r = testResults.results || {};
                                                        const c = r.classic || {};
                                                        const i = r.intelligent || {};
                                                        const rows = [
                                                            { id: 'cumulativeReleased', label: '📤 Total vehículos que SALIERON (toda la prueba)', unit: 'autos', a: c.cumulativeReleased, b: i.cumulativeReleased },
                                                            { id: 'effReleasedDelta', label: '📥 Vehículos en COLA al final (sin salir)', unit: 'autos', a: c.queueEndTotal, b: i.queueEndTotal },
                                                            { id: 'avgWaitSec', label: '⏱️ Tiempo de espera promedio por vehículo', unit: 'segundos', a: c.avgWaitSec, b: i.avgWaitSec },
                                                        ];
                                                        return rows.map((row) => {
                                                            // Determine winner per row: higher released better, lower wait/queue better
                                                            let winner = null;
                                                            const aVal = (row.a == null) ? null : Number(row.a);
                                                            const bVal = (row.b == null) ? null : Number(row.b);
                                                            if (aVal != null && bVal != null) {
                                                                if (row.id === 'avgWaitSec' || row.id === 'effReleasedDelta') {
                                                                    // lower is better
                                                                    winner = aVal < bVal ? 'classic' : (bVal < aVal ? 'intelligent' : 'tie');
                                                                } else {
                                                                    // higher is better
                                                                    winner = aVal > bVal ? 'classic' : (bVal > aVal ? 'intelligent' : 'tie');
                                                                }
                                                            }
                                                            const aBadge = winner === 'classic' ? 'bg-cyan-700/60' : '';
                                                            const bBadge = winner === 'intelligent' ? 'bg-green-700/50' : '';
                                                            const aFmt = formatMetricValue(aVal, row.id);
                                                            const bFmt = formatMetricValue(bVal, row.id);
                                                            const deltaPct = (aVal != null && bVal != null) ? computeDeltaPercent(aVal, bVal) : null;
                                                            const deltaLabel = deltaPct == null ? '' : `${deltaPct > 0 ? '+' : ''}${deltaPct}%`;
                                                            return (
                                                                <tr key={row.id} className="align-top border-b border-cyan-900/40">
                                                                    <td className="p-2 text-cyan-300 text-[12px] font-medium align-middle">{row.label}</td>
                                                                    <td className={`p-2 text-cyan-100 text-sm text-right whitespace-nowrap ${aBadge}`}><div className="font-mono">{aFmt} {row.unit}</div></td>
                                                                    <td className={`p-2 text-cyan-100 text-sm text-right whitespace-nowrap ${bBadge}`}><div className="font-mono">{bFmt} {row.unit}</div></td>
                                                                    <td className="p-2 text-xs text-cyan-400 text-right whitespace-nowrap">{deltaLabel}</td>
                                                                </tr>
                                                            );
                                                        });
                                                    })()}
                                                </tbody>
                                            </table>
                                            {/* Diagnostic hint when Intelligent returned no data */}
                                            {(() => {
                                                try {
                                                    const r = testResults.results || {};
                                                    const c = r.classic || {};
                                                    const i = r.intelligent || {};
                                                    if ((i.cumulativeReleased == null || Number(i.cumulativeReleased) === 0) && (c.cumulativeReleased != null && Number(c.cumulativeReleased) > 0)) {
                                                        return (
                                                            <div className="mt-3 p-2 rounded bg-yellow-900/60 text-yellow-200 text-sm">
                                                                Nota: El modo Inteligente no registró liberados en esta prueba. Intente aumentar la duración de la prueba o ejecutar nuevamente (la lógica GreenWave requiere una inicialización y warm-up).
                                                            </div>
                                                        );
                                                    }
                                                } catch (e) { _noop(e); }
                                                return null;
                                            })()}
                                            <div className="mt-3 text-[12px] text-cyan-300 font-medium">Detalles de diagnóstico</div>
                                            <div className="mt-2 bg-black/80 p-2 rounded text-xs text-cyan-200">
                                                <div className="grid grid-cols-2 gap-2">
                                                    <div>
                                                        <div className="text-cyan-300 font-semibold">Clásico</div>
                                                        <div>perfWaitsCaptured: {testResults.results?.classic?.debug?.perfWaitsCaptured ?? '—'}</div>
                                                        <div>perfWaitsTotal: {testResults.results?.classic?.debug?.perfWaitsTotal ?? '—'}</div>
                                                        <div>effTotalLiberadosRaw: {testResults.results?.classic?.debug?.effTotalLiberadosRaw ?? '—'}</div>
                                                    </div>
                                                    <div>
                                                        <div className="text-cyan-300 font-semibold">Inteligente</div>
                                                        <div>perfWaitsCaptured: {testResults.results?.intelligent?.debug?.perfWaitsCaptured ?? '—'}</div>
                                                        <div>perfWaitsTotal: {testResults.results?.intelligent?.debug?.perfWaitsTotal ?? '—'}</div>
                                                        <div>effTotalLiberadosRaw: {testResults.results?.intelligent?.debug?.effTotalLiberadosRaw ?? '—'}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div className="mt-3 text-[12px] text-cyan-300">
                                                <strong>Ganador final:</strong>{' '}
                                                {testResults.winner === 'intelligent' ? (
                                                    <span className="text-green-300 font-bold">Inteligente</span>
                                                ) : testResults.winner === 'classic' ? (
                                                    <span className="text-cyan-300 font-bold">Clásico</span>
                                                ) : (
                                                    <span className="text-yellow-300 font-bold">Empate</span>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    <div className="mb-2">Diagnóstico:</div>
                                    <div className="bg-black/80 p-2 rounded text-[12px] text-cyan-200 space-y-2">
                                        <div>
                                            <strong className="text-cyan-100">Recomendación:</strong>{' '}
                                            {testResults.winner === 'intelligent' ? (
                                                <span>El modo Inteligente mostró mejor desempeño según la métrica combinada. Considerar activar GreenWave para esta intersección.</span>
                                            ) : testResults.winner === 'classic' ? (
                                                <span>El modo Clásico fue mejor en esta ejecución. Revisar parámetros de GreenWave o aumentar su ventana de evaluación.</span>
                                            ) : (
                                                <span>Empate técnico. Repetir pruebas con mayor duración o condiciones variadas.</span>
                                            )}
                                        </div>
                                        <div>
                                            <strong className="text-cyan-100">Detalles:</strong>
                                            <div className="mt-1 text-[11px] text-cyan-300">
                                                - Clásico: liberados Δ = {testResults.results?.classic?.effReleasedDelta ?? testResults.results?.classic?.releasedDelta ?? 'N/A'}, espera media = {testResults.results?.classic?.avgWaitSec ?? 'N/A'}s, cola fin = {testResults.results?.classic?.queueEndTotal ?? 'N/A'}
                                            </div>
                                            <div className="mt-1 text-[11px] text-cyan-300">
                                                - Inteligente: liberados Δ = {testResults.results?.intelligent?.effReleasedDelta ?? testResults.results?.intelligent?.releasedDelta ?? 'N/A'}, espera media = {testResults.results?.intelligent?.avgWaitSec ?? 'N/A'}s, cola fin = {testResults.results?.intelligent?.queueEndTotal ?? 'N/A'}
                                            </div>
                                        </div>
                                        <div className="mt-2 text-[11px] text-cyan-400">Pista: pulsa 'Iniciar pruebas' varias veces para promediar resultados y reducir varianza.</div>
                                    </div>

                                    <details className="mt-2 text-[11px] text-cyan-200">
                                        <summary className="cursor-pointer text-cyan-300">Mostrar JSON bruto</summary>
                                        <pre className="bg-black/80 p-2 rounded text-[11px] text-cyan-200 mt-2">{JSON.stringify(testResults, null, 2)}</pre>
                                    </details>
                                </div>
                            ) : (
                                <div className="text-cyan-400/60">No hay resultados aún.</div>
                            )}
                        </div>
                    </div>
                </div>
            )}

            {/* Banner con Logo Xlerion + controles rápidos */}
            <div className="absolute top-0 left-0 right-0 bg-black/70 backdrop-blur-md border-b border-cyan-500/30 px-4 py-3 flex items-center justify-between gap-4 shadow-lg shadow-cyan-500/10">
                <div className="flex items-center gap-3">
                    <button
                        onClick={() => setIsTrafficPanelExpanded(!isTrafficPanelExpanded)}
                        className="px-3 py-2 rounded-md bg-gradient-to-r from-cyan-600/60 to-cyan-600/30 hover:from-cyan-500/70 hover:to-cyan-500/40 border border-cyan-400/50 text-cyan-100 text-xs font-bold uppercase tracking-wide transition-all"
                        title="Panel de Tráfico"
                    >
                        🚦 Tráfico
                    </button>
                    <button
                        onClick={() => setShowAdvancedControls(prev => !prev)}
                        className="px-3 py-2 rounded-md bg-black/40 border border-cyan-400/30 text-cyan-100 text-xs font-bold uppercase tracking-wide transition-all"
                        title="Controles avanzados"
                    >
                        ⚙️ Controles
                    </button>
                    <button
                        onClick={() => setShowSemInfo(prev => !prev)}
                        className="px-3 py-2 rounded-md bg-gradient-to-r from-slate-800/80 to-slate-700/60 hover:from-slate-700/80 hover:to-slate-600/60 border border-cyan-400/30 text-cyan-100 text-[11px] font-bold uppercase tracking-wide transition-all"
                        title={showSemInfo ? 'Ocultar HUD de semáforos' : 'Mostrar HUD de semáforos'}
                    >
                        {showSemInfo ? 'Ocultar HUD' : 'Mostrar HUD'}
                    </button>
                    <button
                        onClick={() => setShowDebugPanel(prev => !prev)}
                        className="px-2 py-1 rounded-md bg-black/40 border border-cyan-400/30 text-cyan-100 text-[11px] font-bold uppercase tracking-wide transition-all"
                        title={showDebugPanel ? 'Ocultar panel Debug' : 'Mostrar panel Debug'}
                    >
                        🪲 Debug
                    </button>
                    <button
                        onClick={() => setShowTestModal(true)}
                        className="px-2 py-1 rounded-md bg-black/40 border border-cyan-400/30 text-cyan-100 text-[11px] font-bold uppercase tracking-wide transition-all"
                        title="Comparar modos (ejecutar pruebas)"
                    >
                        ⚖️ Comparar modos
                    </button>
                    <div className="text-[11px] text-cyan-200 uppercase tracking-wide">Sistema Adaptativo</div>
                </div>
                <img
                    src="/XlerionGreenWaveLogo.png"
                    alt="Xlerion GreenWave"
                    className="h-10 object-contain"
                />
                <div className="text-right text-[11px] text-cyan-300 uppercase tracking-wide">
                    Modo: {trafficLightMode === 'classic' ? 'Clásico' : 'Inteligente / GreenWave'}
                </div>
            </div>

            {/* Advanced controls panel (outside the 3D viewer) */}
            {showAdvancedControls && (
                <div className="absolute left-1/2 transform -translate-x-1/2 bottom-6 bg-black/85 border border-cyan-600/30 rounded-lg p-4 shadow-xl z-40">
                    <div className="flex flex-wrap gap-2">
                        <button onClick={() => setShowAlgorithmAuth(true)} className="px-3 py-2 rounded bg-indigo-900 border border-indigo-600 text-indigo-200 hover:bg-indigo-800 transition-colors">💡 Algoritmo</button>
                        <button onClick={() => setShowTechDocAuth(true)} className="px-3 py-2 rounded bg-blue-900 border border-blue-600 text-blue-200 hover:bg-blue-800 transition-colors">📄 Doc. Técnica</button>
                        <button onClick={() => setShowIPProtection(true)} className="px-3 py-2 rounded bg-purple-900 border border-purple-600 text-purple-200 hover:bg-purple-800 transition-colors">©️ Derechos</button>
                    </div>
                </div>
            )}

            {/* Efficiency comparison panel (Classic vs GreenWave) - center-right collapsible */}
            {/* Panel de eficiencia (desplegable desde la derecha) */}
            <div className={`absolute right-0 top-1/2 transform -translate-y-1/2 z-10 transition-transform duration-300 ${effPanelOpen ? 'translate-x-0' : 'translate-x-full'}`}>
                {/* Botón de toggle (se mueve con el panel) */}
                <button
                    aria-label={effPanelOpen ? 'Cerrar panel de eficiencia' : 'Abrir panel de eficiencia'}
                    onClick={() => setEffPanelOpen(prev => !prev)}
                    className="absolute -left-8 top-0 bg-cyan-600/30 hover:bg-cyan-600/50 text-cyan-50 rounded-l-md px-2 py-2 shadow-lg"
                    title={effPanelOpen ? 'Cerrar panel' : 'Abrir panel'}
                >
                    {effPanelOpen ? '▶' : '◀'}
                </button>

                {/* Contenido del panel */}
                <div className="mr-4">
                    <div className="w-96 bg-black/80 p-3 rounded-md border border-cyan-600/30 text-sm text-white shadow-2xl">
                        <div className="flex items-center justify-between mb-2">
                            <div className="text-xs uppercase text-cyan-200 font-bold">Panel de Eficiencia</div>
                            <div className="text-[11px] text-cyan-300">Comparativa: Clásico / GreenWave™</div>
                        </div>
                        {stats?.efficiencyComparison ? (
                            <div className="grid grid-cols-3 gap-2 text-[13px]">
                                <div className="col-span-1 text-cyan-300">Métrica</div>
                                <div className="col-span-1 text-left text-gray-200">Clásico</div>
                                <div className="col-span-1 text-left text-gray-200">GreenWave</div>

                                <div className="text-cyan-200">Tiempo medio espera (s)</div>
                                <div className={(stats.efficiencyComparison.avgWait?.winner === 'classic' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.avgWait?.classic ?? 'N/A'}</div>
                                <div className={(stats.efficiencyComparison.avgWait?.winner === 'intelligent' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.avgWait?.intelligent ?? 'N/A'}</div>

                                <div className="text-cyan-200">Vehículos liberados (ciclo)</div>
                                <div className={(stats.efficiencyComparison.released?.winner === 'classic' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.released?.classic ?? 'N/A'}</div>
                                <div className={(stats.efficiencyComparison.released?.winner === 'intelligent' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.released?.intelligent ?? 'N/A'}</div>

                                <div className="text-cyan-200">Promedio Rojo→Verde (s)</div>
                                <div className={(stats.efficiencyComparison.redToGreenAvg?.winner === 'classic' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.redToGreenAvg?.classic ?? 'N/A'}</div>
                                <div className={(stats.efficiencyComparison.redToGreenAvg?.winner === 'intelligent' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.redToGreenAvg?.intelligent ?? 'N/A'}</div>

                                <div className="text-cyan-200">Desviación Rojo→Verde (s)</div>
                                <div className={(stats.efficiencyComparison.redToGreenStd?.winner === 'classic' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.redToGreenStd?.classic ?? 'N/A'}</div>
                                <div className={(stats.efficiencyComparison.redToGreenStd?.winner === 'intelligent' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.redToGreenStd?.intelligent ?? 'N/A'}</div>

                                <div className="text-cyan-200">Vehículos en cola (fin ciclo)</div>
                                <div className={(stats.efficiencyComparison.queueEndTotal?.winner === 'classic' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.queueEndTotal?.classic ?? 'N/A'}</div>
                                <div className={(stats.efficiencyComparison.queueEndTotal?.winner === 'intelligent' ? 'text-green-300 ' : '') + 'whitespace-nowrap text-right'}>{stats.efficiencyComparison.queueEndTotal?.intelligent ?? 'N/A'}</div>
                            </div>
                        ) : (
                            <div className="text-[13px] text-gray-300">No hay datos suficientes — esperando mediciones válidas</div>
                        )}
                    </div>
                </div>
            </div>

            {/* Panel de Control Lateral Derecho */}
            <div className={`absolute top-20 right-4 ${showTestModal ? 'z-20' : 'z-30'} bg-gradient-to-b from-black/95 to-black/80 border-2 border-cyan-500/40 rounded-lg p-5 text-cyan-300 font-mono text-sm backdrop-blur-sm min-w-[280px] shadow-2xl shadow-cyan-500/20 flex flex-col max-h-[calc(100vh-6rem)] transition-all duration-300`}
                onWheel={(e) => e.stopPropagation()}
            >
                {/* Encabezado */}
                <div className={`flex items-center justify-between mb-4 pb-3 border-b transition-colors duration-300 flex-shrink-0 ${configChanged ? 'border-green-500/60 bg-green-900/20' : 'border-cyan-500/40'}`}>
                    <div className="flex-1">
                        <div className="text-lg font-bold text-cyan-400 tracking-wider">🚦 SISTEMA ADAPTATIVO</div>
                        <div className="text-[10px] text-cyan-500/60 mt-1">INTERSECCIÓN URBANA INTELIGENTE</div>
                        {configChanged && <div className="text-[9px] text-green-400 mt-1">✓ Configuración aplicada</div>}
                    </div>
                    <button
                        onClick={() => setIsPanelExpanded(!isPanelExpanded)}
                        className="flex-shrink-0 ml-3 text-cyan-400 hover:text-cyan-200 text-xl transition-colors"
                        title={isPanelExpanded ? 'Minimizar' : 'Expandir'}
                    >
                        {isPanelExpanded ? '▼' : '▶'}
                    </button>
                </div>

                {/* Contenedor scrollable */}
                {isPanelExpanded && (
                    <div className="overflow-y-auto flex-1 pr-2 space-y-4">
                        {/* Configuración de escenario */}
                        <div className="space-y-3 bg-cyan-900/20 border border-cyan-500/20 rounded p-3">
                            <div className="flex items-center justify-between text-[11px] text-cyan-300">
                                <span>Ciudad</span>
                                <select
                                    value={selectedCity}
                                    onChange={(e) => setSelectedCity(e.target.value)}
                                    className="bg-black/40 border border-cyan-500/40 rounded px-2 py-1 text-xs text-cyan-100"
                                >
                                    {Object.entries(CITIES_DATA).map(([key, data]) => (
                                        <option key={key} value={key}>{data.name}</option>
                                    ))}
                                </select>
                            </div>

                            <div className="flex items-center justify-between text-[11px] text-cyan-300">
                                <span>Intersección</span>
                                <select
                                    value={selectedIntersection}
                                    onChange={(e) => setSelectedIntersection(e.target.value)}
                                    className="bg-black/40 border border-cyan-500/40 rounded px-2 py-1 text-[11px] text-cyan-100 max-w-[170px]"
                                >
                                    {(CITIES_DATA[selectedCity]?.intersections || []).map(inter => (
                                        <option key={inter.id} value={inter.id}>{inter.name}</option>
                                    ))}
                                </select>
                            </div>

                            <div className="text-[11px] text-cyan-300">
                                <div className="flex justify-between">
                                    <span>Hora simulada</span>
                                    <span className="font-mono text-cyan-100">{selectedHour}:00</span>
                                </div>
                                <input
                                    type="range"
                                    min={0}
                                    max={23}
                                    value={selectedHour}
                                    onChange={(e) => setSelectedHour(parseInt(e.target.value, 10))}
                                    className="w-full accent-cyan-400"
                                />
                            </div>

                            {currentIntersection && (
                                <div className="text-[11px] text-cyan-200 bg-black/30 border border-cyan-500/20 rounded p-2 space-y-2">
                                    <div className="font-semibold text-cyan-100">{currentIntersection.name}</div>
                                    <div className="text-cyan-400/80">{currentIntersection.region}</div>
                                    <div className="text-amber-300/90">Nivel: {dynamicTrafficLevel}</div>
                                    <div className="border-t border-cyan-500/20 pt-2">
                                        <div className="text-[10px] text-cyan-400/70 mb-1">Generación de vehículos:</div>
                                        <div className="flex items-center justify-between">
                                            <span className="text-cyan-300">
                                                {currentGenerationIntensity.intensity === 'PICO' && '🔴 PICO'}
                                                {currentGenerationIntensity.intensity === 'NORMAL' && '🟡 NORMAL'}
                                                {currentGenerationIntensity.intensity === 'VALLE' && '🟢 VALLE'}
                                            </span>
                                            <span className="text-amber-300 font-mono text-[10px]">{currentGenerationIntensity.percentage}%</span>
                                        </div>
                                        <div className="w-full bg-black/50 rounded-full h-1.5 mt-1 overflow-hidden border border-cyan-500/20">
                                            <div
                                                className={`h-full transition-all duration-300 ${currentGenerationIntensity.intensity === 'PICO' ? 'bg-red-500/70' :
                                                    currentGenerationIntensity.intensity === 'NORMAL' ? 'bg-yellow-500/70' :
                                                        'bg-green-500/70'
                                                    }`}
                                                style={{ width: `${currentGenerationIntensity.percentage}%` }}
                                            />
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Fase Activa */}
                        <div className="mb-4 p-3 bg-cyan-900/30 border border-cyan-500/30 rounded">
                            <div className="text-[11px] text-cyan-500/70 uppercase tracking-wide mb-2">Fase Activa</div>
                            <div className="text-2xl font-bold text-yellow-300 text-center">
                                {phase === 'NS' ? '⬆️⬇️' : '⬅️➡️'}
                            </div>
                            <div className="text-xs text-center text-cyan-400 mt-1">
                                {phase === 'NS' ? 'NORTE ↔ SUR' : 'ESTE ↔ OESTE'}
                            </div>
                        </div>

                        {/* Estado por Dirección */}
                        <div className="mb-4">
                            <div className="text-[11px] text-cyan-500/70 uppercase tracking-wide mb-2 px-1">Estado por Dirección</div>
                            <div className="grid grid-cols-4 gap-2">
                                {['N', 'S', 'E', 'W'].map(dir => {
                                    const isActive = (phase === 'NS' && (dir === 'N' || dir === 'S')) ||
                                        (phase === 'EW' && (dir === 'E' || dir === 'W'));
                                    const directionsMap = { N: '⬆️', S: '⬇️', E: '➡️', W: '⬅️' };
                                    return (
                                        <div
                                            key={dir}
                                            className={`${isActive
                                                ? 'bg-green-900/50 border-2 border-green-500/80 shadow-lg shadow-green-500/30'
                                                : 'bg-red-900/30 border border-red-500/40'
                                                } rounded p-2 text-center transition-all duration-300`}
                                        >
                                            <div className="text-lg font-bold">{directionsMap[dir]}</div>
                                            <div className="text-xs text-gray-400 mt-1">E: {stats.waiting[dir]}</div>
                                            <div className="text-xs text-green-400">L: {stats.active[dir]}</div>
                                            <div className={`text-xs mt-1 ${waitingTimeDisplay[dir] > WAITING_TIME_THRESHOLD ? 'text-red-400 font-bold' : 'text-cyan-300'}`}>
                                                W: {waitingTimeDisplay[dir]} ticks
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* Leyenda */}
                        <div className="mb-4 text-[10px] text-cyan-500/50 space-y-0.5 px-1 border-t border-cyan-500/20 pt-2">
                            <div><span className="text-cyan-400">E:</span> En espera (carril entrada)</div>
                            <div><span className="text-cyan-400">L:</span> Liberados (cruzando/salida)</div>
                        </div>

                        {/* Liberados por fase */}
                        <div className="bg-cyan-900/25 border border-cyan-500/30 rounded p-3 mb-3">
                            <div className="text-[11px] text-cyan-500/70 uppercase tracking-wide mb-2">Liberados en fase actual</div>
                            <div className="grid grid-cols-2 gap-2 text-xs text-cyan-100">
                                <div>N: <span className="font-mono text-green-400">{stats.lastPhase.N}</span></div>
                                <div>S: <span className="font-mono text-green-400">{stats.lastPhase.S}</span></div>
                                <div>E: <span className="font-mono text-green-400">{stats.lastPhase.E}</span></div>
                                <div>O: <span className="font-mono text-green-400">{stats.lastPhase.W}</span></div>
                            </div>
                            <div className="text-xs text-cyan-300 mt-2">Total fase: <span className="font-mono text-yellow-300">{stats.lastPhase.total}</span></div>
                        </div>

                        {/* Métricas */}
                        <div className="bg-gradient-to-r from-cyan-900/40 to-cyan-900/20 border border-cyan-500/30 rounded p-3 mb-3 space-y-2">
                            <div className="flex justify-between text-xs">
                                <span className="text-cyan-500/70">FASE:</span>
                                <span className="font-bold text-cyan-300">{phase}</span>
                            </div>
                            <div className="flex justify-between text-xs">
                                <span className="text-cyan-500/70">LIBERADOS:</span>
                                <span className="font-bold text-green-400">{stats.totalReleased}</span>
                            </div>
                            <div className="flex justify-between text-xs">
                                <span className="text-cyan-500/70">EFICIENCIA:</span>
                                <span className="font-bold text-yellow-400">{stats.efficiency}%</span>
                            </div>
                        </div>

                        {/* Totales acumulados */}
                        <div className="bg-cyan-900/20 border border-cyan-500/30 rounded p-3 mb-4 space-y-2">
                            <div className="text-[11px] text-cyan-500/70 uppercase tracking-wide">Totales acumulados</div>
                            <div className="grid grid-cols-2 gap-2 text-xs text-cyan-100">
                                <div>N: <span className="font-mono text-emerald-400">{stats.totals.N}</span></div>
                                <div>S: <span className="font-mono text-emerald-400">{stats.totals.S}</span></div>
                                <div>E: <span className="font-mono text-emerald-400">{stats.totals.E}</span></div>
                                <div>O: <span className="font-mono text-emerald-400">{stats.totals.W}</span></div>
                            </div>
                            <div className="text-xs text-cyan-300">Total liberados: <span className="font-mono text-yellow-300">{stats.totalReleased}</span></div>
                        </div>

                        {/* Metadatos de Vehículos */}
                        <div className="bg-gradient-to-b from-indigo-900/30 to-purple-900/20 border border-purple-500/40 rounded p-3 mb-4 space-y-3">
                            <div className="text-[11px] text-purple-400 uppercase tracking-wide font-bold flex items-center gap-2">
                                <span>🚗</span> Metadatos Vehículos
                            </div>

                            {/* Resumen por tipo */}
                            <div className="space-y-1">
                                <div className="text-[10px] text-purple-300/70 uppercase">Por Tipo:</div>
                                {['N', 'S', 'E', 'W'].map(dir => {
                                    const { cars, buses, motorcycles } = stats.metadata.byType[dir];
                                    const total = cars + buses + motorcycles;

                                    if (total === 0) return null;

                                    return (
                                        <div key={dir} className="text-[9px] text-purple-200 bg-black/30 rounded px-2 py-1">
                                            <span className="text-purple-400 font-bold">{dir}:</span>
                                            <span className="text-blue-400 ml-1">🚙{cars}</span>
                                            <span className="text-amber-400 ml-1">🚌{buses}</span>
                                            <span className="text-red-400 ml-1">🏍️{motorcycles}</span>
                                        </div>
                                    );
                                })}
                            </div>

                            {/* Renderizados en escena (1:1 con lo visible) */}
                            <div className="border-t border-purple-500/20 pt-2 space-y-1">
                                <div className="text-[10px] text-purple-300/70 uppercase">Renderizados en escena</div>
                                <div className="text-[10px] text-purple-100">
                                    Total visibles: <span className="font-mono text-amber-300">{stats.rendered.total}</span>
                                </div>
                                <div className="flex items-center gap-2 text-[10px] text-purple-100">
                                    <span className="text-blue-400">🚙 {stats.rendered.byType.car}</span>
                                    <span className="text-amber-400">🚌 {stats.rendered.byType.bus}</span>
                                    <span className="text-red-400">🏍️ {stats.rendered.byType.motorcycle}</span>
                                </div>
                            </div>

                            {/* Triggers */}
                            <div className="border-t border-purple-500/20 pt-2 space-y-1">
                                <div className="text-[10px] text-purple-300/70 uppercase">Triggers Activos:</div>
                                {['N', 'S', 'E', 'W'].map(dir => {
                                    const { inQueue, released, exitTriggered } = stats.metadata.byTrigger[dir];

                                    if (inQueue === 0 && exitTriggered === 0 && released === 0) return null;

                                    return (
                                        <div key={dir} className="text-[9px] text-purple-200 bg-black/30 rounded px-2 py-1 grid grid-cols-3 gap-1">
                                            <span className="text-purple-400 font-bold">{dir}:</span>
                                            <span className="text-yellow-400">Q:{inQueue}</span>
                                            <span className="text-green-400">R:{released}</span>
                                        </div>
                                    );
                                })}
                            </div>

                            {/* Leyenda */}
                            <div className="text-[8px] text-purple-400/60 border-t border-purple-500/20 pt-2 space-y-0.5">
                                <div>Q: En cola (trigger entrada)</div>
                                <div>R: Liberados (pueden cruzar)</div>
                            </div>
                        </div>
                    </div>
                )}

                {/* Control */}
                <button
                    onClick={() => setIsRunning(!isRunning)}
                    className="w-full bg-gradient-to-r from-cyan-600/30 to-cyan-600/10 hover:from-cyan-600/50 hover:to-cyan-600/30 border border-cyan-500/50 text-cyan-300 px-3 py-2 rounded text-xs font-bold transition-all duration-200 uppercase tracking-wide flex-shrink-0 mt-4"
                >
                    {isRunning ? '⏸ PAUSAR' : '▶ REANUDAR'}
                </button>
            </div>

            {/* Leyenda de Vehículos (izquierda abajo) - Panel Desplegable */}
            <div className={`absolute left-0 bottom-4 z-30 transition-transform duration-300 ${legendPanelOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                {/* Botón de toggle (se mueve con el panel) */}
                <button
                    aria-label={legendPanelOpen ? 'Ocultar leyenda' : 'Mostrar leyenda'}
                    onClick={() => setLegendPanelOpen(prev => !prev)}
                    className="absolute -right-8 top-0 bg-cyan-600/30 hover:bg-cyan-600/50 text-cyan-50 rounded-r-md px-2 py-3 shadow-lg"
                    title={legendPanelOpen ? 'Ocultar leyenda' : 'Mostrar leyenda'}
                >
                    {legendPanelOpen ? '◀' : '▶'}
                </button>

                {/* Contenido del panel */}
                <div className="ml-4">
                    <div className="bg-gradient-to-b from-black/95 to-black/80 border-2 border-cyan-500/40 rounded-lg p-4 text-cyan-300 font-mono text-xs backdrop-blur-sm shadow-lg shadow-cyan-500/10">
                        <div className="font-bold mb-3 text-cyan-400 text-sm uppercase tracking-wide">Tipos de Vehículos</div>
                        <div className="space-y-2">
                            <div className="flex items-center gap-3">
                                <div className="w-6 h-4 rounded bg-blue-500 shadow-sm shadow-blue-500/50"></div>
                                <span className="text-cyan-300">Auto (Car)</span>
                            </div>
                            <div className="flex items-center gap-3">
                                <div className="w-6 h-4 rounded bg-amber-500 shadow-sm shadow-amber-500/50"></div>
                                <span className="text-cyan-300">Bus</span>
                            </div>
                            <div className="flex items-center gap-3">
                                <div className="w-6 h-4 rounded bg-red-500 shadow-sm shadow-red-500/50"></div>
                                <span className="text-cyan-300">Motocicleta</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {/* Panel de Control de Tráfico (overlay disparado desde el banner) */}
            {isTrafficPanelExpanded && (
                <div className="absolute top-16 left-4 bg-gradient-to-b from-black/95 to-black/80 border-2 border-cyan-500/40 rounded-lg p-4 text-cyan-300 font-mono text-xs backdrop-blur-sm shadow-lg shadow-cyan-500/10 w-72">
                    {/* Encabezado */}
                    <div className="flex items-center justify-between mb-4 pb-3 border-b border-cyan-500/40">
                        <div className="text-sm font-bold text-cyan-400 tracking-wider">CONTROL DE TRÁFICO</div>
                        <button
                            onClick={() => setIsTrafficPanelExpanded(false)}
                            className="text-cyan-400 hover:text-cyan-200 text-lg transition-colors"
                        >
                            ✕
                        </button>
                    </div>

                    {/* Selector de Modo de Semáforo */}
                    <div className="space-y-3 mb-4">
                        <div className="text-[11px] text-cyan-400 font-bold uppercase tracking-wide mb-2">Tipo de Semáforo</div>
                        <div className="space-y-2">
                            <button
                                onClick={() => setTrafficLightMode('classic')}
                                className={`w-full px-3 py-2 rounded text-xs font-bold uppercase transition-all duration-200 ${trafficLightMode === 'classic'
                                    ? 'bg-yellow-600/50 border-2 border-yellow-500/70 text-yellow-200 shadow-lg shadow-yellow-500/30'
                                    : 'bg-black/40 border border-cyan-500/30 text-cyan-300 hover:border-cyan-500/50'
                                    }`}
                                title="Semáforo clásico con tiempos fijos"
                            >
                                🔴 CLÁSICO
                            </button>
                            <button
                                onClick={() => { setTrafficLightMode('intelligent'); resetGreenWaveRequestRef.current = true; }}
                                className={`w-full px-3 py-2 rounded text-xs font-bold uppercase transition-all duration-200 ${trafficLightMode === 'intelligent'
                                    ? 'bg-emerald-600/50 border-2 border-emerald-500/70 text-emerald-200 shadow-lg shadow-emerald-500/30'
                                    : 'bg-black/40 border border-cyan-500/30 text-cyan-300 hover:border-cyan-500/50'
                                    }`}
                                title="Modo Inteligente / GreenWave unificado"
                            >
                                🧠♻️ INTELIGENTE / GREENWAVE
                            </button>
                        </div>
                    </div>

                    {/* Indicador de Modo Actual */}
                    <div className="bg-cyan-900/30 border border-cyan-500/30 rounded p-3 mb-4">
                        <div className="text-[10px] text-cyan-500/70 uppercase tracking-wide mb-1">Modo Activo</div>
                        <div className="text-sm font-bold text-cyan-300">
                            {trafficLightMode === 'classic' && '🔴 CLÁSICO'}
                            {trafficLightMode === 'intelligent' && '🧠♻️ INTELIGENTE / GREENWAVE'}
                        </div>
                    </div>

                    {/* Información del Modo */}
                    <div className="bg-black/40 border border-cyan-500/20 rounded p-3 mb-4 text-[10px] text-cyan-200 leading-relaxed">
                        {trafficLightMode === 'classic' && (
                            <div>
                                <div className="font-bold text-cyan-400 mb-1">Semáforo Clásico</div>
                                Tiempos fijos predeterminados. Eficiencia básica en condiciones normales.
                            </div>
                        )}
                        {trafficLightMode === 'intelligent' && (
                            <div>
                                <div className="font-bold text-emerald-400 mb-1">Modo Inteligente / GreenWave</div>
                                Algoritmo adaptativo con respuesta a accidentes y optimización de flujo continuo.
                            </div>
                        )}
                    </div>

                    {/* Velocidad Vehículos (control global) */}
                    <div className="bg-cyan-900/20 border border-cyan-500/30 rounded p-3 mb-4">
                        <div className="text-[11px] text-cyan-400 font-bold uppercase tracking-wide mb-2">Velocidad Vehículos</div>
                        <div className="flex items-center gap-3">
                            <input
                                type="range"
                                min={0.2}
                                max={3}
                                step={0.1}
                                value={speedMultiplier}
                                onChange={(e) => setSpeedMultiplier(parseFloat(e.target.value))}
                                className="w-full"
                            />
                            <div className="text-xs text-cyan-200 font-mono">x{(speedMultiplier ?? 1).toFixed(1)}</div>
                        </div>
                        <div className="text-[9px] text-cyan-500/60 mt-2">Ajusta la velocidad de los vehículos (no afecta lógica de semáforos).</div>
                    </div>

                    {/* Botón de Accidente */}
                    <div className="space-y-2 border-t border-cyan-500/30 pt-4">
                        <div className="text-[11px] text-cyan-400 font-bold uppercase tracking-wide mb-2">Simulación de Eventos</div>
                        <button
                            onClick={triggerAccident}
                            className={`w-full px-3 py-3 rounded text-xs font-bold uppercase transition-all duration-200 ${accidentActive
                                ? 'bg-red-600/60 border-2 border-red-500/80 text-red-100 shadow-lg shadow-red-500/40 animate-pulse'
                                : 'bg-black/40 border border-red-500/30 text-red-300 hover:border-red-500/60 hover:bg-red-900/20'
                                }`}
                            disabled={accidentActive}
                            title={accidentActive ? `🚨 ACCIDENTE ACTIVO en dirección ${accidentLocation}` : 'Generar un accidente aleatorio'}
                        >
                            {accidentActive ? `🚨 ACCIDENTE: ${accidentLocation}` : '⚠️ GENERAR ACCIDENTE'}
                        </button>
                        <div className="text-[9px] text-cyan-500/60">
                            {accidentActive ? 'Duración: 10 segundos' : 'Presiona para simular un evento'}
                        </div>
                    </div>

                    {/* Estadísticas del Accidente */}
                    {accidentActive && accidentLocation && (
                        <div className="mt-4 p-3 bg-red-900/30 border border-red-500/40 rounded text-[10px] text-red-300">
                            <div className="font-bold mb-2">IMPACTO DEL ACCIDENTE:</div>
                            <div>• Ubicación: {accidentLocation === 'N' ? 'NORTE ⬆️' : accidentLocation === 'S' ? 'SUR ⬇️' : accidentLocation === 'E' ? 'ESTE ➡️' : 'OESTE ⬅️'}</div>
                            <div>• Circulación bloqueada: -60%</div>
                            <div>• Congestión esperada</div>
                            <div>• Rerouting de tráfico</div>
                        </div>
                    )}

                </div>
            )}

            {/* Instrucciones de Cámara y Pausar (izquierda, arriba de leyenda) - Panel Desplegable */}
            {/* Panel de controles (desplegable desde la izquierda) */}
            <div className={`absolute left-0 bottom-48 z-40 transition-transform duration-300 ${controlsPanelOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                {/* Botón de toggle (se mueve con el panel) */}
                <button
                    aria-label={controlsPanelOpen ? 'Ocultar controles' : 'Mostrar controles'}
                    onClick={() => setControlsPanelOpen(prev => !prev)}
                    className="absolute -right-8 top-0 bg-cyan-600/30 hover:bg-cyan-600/50 text-cyan-50 rounded-r-md px-2 py-3 shadow-lg"
                    title={controlsPanelOpen ? 'Ocultar panel' : 'Mostrar panel'}
                >
                    {controlsPanelOpen ? '◀' : '▶'}
                </button>

                {/* Contenido del panel */}
                <div className="ml-4">
                    <div className="bg-black/85 border border-cyan-600/30 rounded-lg p-4 shadow-xl space-y-3">
                        <div className="bg-black/70 border border-cyan-500/30 rounded px-3 py-2 text-cyan-400/80 text-[11px] font-mono backdrop-blur-sm">
                            <div className="font-bold mb-1">CONTROLES:</div>
                            <div>🖱️ Arrastrar = Rotar</div>
                            <div>⛏️ Rueda = Zoom</div>
                            <div className="text-[9px] text-cyan-500/60 mt-1">Vista cenital recomendada</div>
                        </div>
                        <button onClick={() => setIsRunning(prev => !prev)} className="w-full px-3 py-2 rounded bg-gray-800 border border-cyan-500 text-cyan-100 hover:bg-gray-700 transition-colors">
                            {isRunning ? '⏸ PAUSAR' : '▶ REANUDAR'}
                        </button>
                    </div>
                </div>
            </div>

            {/* Algorithm Authentication Modal */}
            {showAlgorithmAuth && (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
                    <div className="bg-gray-900 border-2 border-indigo-600/50 rounded-lg max-w-md w-full">
                        <div className="p-6">
                            <div className="flex items-center justify-between mb-6">
                                <div className="flex items-center gap-3">
                                    <span className="text-4xl">🔐</span>
                                    <div>
                                        <h2 className="text-2xl font-bold text-indigo-400">Acceso Restringido</h2>
                                        <p className="text-sm text-gray-400 mt-1">Algoritmo de GreenWave</p>
                                    </div>
                                </div>
                                <button
                                    onClick={() => {
                                        setShowAlgorithmAuth(false);
                                        setAlgorithmPassword('');
                                        setAlgorithmAuthError('');
                                    }}
                                    className="text-gray-400 hover:text-white transition-colors p-2 hover:bg-gray-800 rounded"
                                >
                                    <X size={24} />
                                </button>
                            </div>
                            <div className="space-y-4">
                                <div className="bg-indigo-900/20 border-l-4 border-indigo-500 p-4 rounded">
                                    <p className="text-sm text-gray-300">
                                        <strong className="text-indigo-400">🔐 Contenido Protegido</strong><br />
                                        Este documento contiene el algoritmo propietario de GreenWave. Se requiere autenticación.
                                    </p>
                                </div>
                                <div>
                                    <label className="block text-sm font-semibold text-indigo-300 mb-2">🔑 Contraseña:</label>
                                    <input
                                        type="password"
                                        value={algorithmPassword}
                                        onChange={(e) => { setAlgorithmPassword(e.target.value); setAlgorithmAuthError(''); }}
                                        placeholder="Ingrese la contraseña"
                                        className="w-full px-4 py-3 bg-gray-800/70 border border-indigo-600/40 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-500/50"
                                        onKeyPress={(e) => { if (e.key === 'Enter' && algorithmPassword.length > 0) { document.querySelector('[data-algo-auth-submit]').click(); } }}
                                        autoFocus
                                    />
                                </div>
                                {algorithmAuthError && (
                                    <div className="bg-red-900/30 border border-red-600/40 rounded-lg p-3 text-sm text-red-400 flex items-start gap-2">
                                        <span>❌</span><span>{algorithmAuthError}</span>
                                    </div>
                                )}
                                <button
                                    data-algo-auth-submit
                                    onClick={() => {
                                        const correctPassword = import.meta.env.VITE_TECHNICAL_DOC_PASSWORD || '81720164';
                                        if (algorithmPassword === correctPassword) {
                                            setAlgorithmAuthError(''); setShowAlgorithmAuth(false); setShowAlgorithm(true); setAlgorithmPassword('');
                                        } else if (algorithmPassword.length === 0) {
                                            setAlgorithmAuthError('Por favor ingrese la contraseña');
                                        } else {
                                            setAlgorithmAuthError('Contraseña incorrecta. Contacte a XLERION (contacto@xlerion.com)');
                                        }
                                    }}
                                    disabled={algorithmPassword.length === 0}
                                    className="w-full px-6 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded-lg font-bold text-white text-lg transition-all flex items-center justify-center gap-3 shadow-lg hover:shadow-xl"
                                >
                                    <span className="text-2xl">🔓</span>Ver Algoritmo
                                </button>
                                <div className="text-xs text-gray-500 text-center pt-2">
                                    ¿No tiene acceso? Contacte a <a href="mailto:contacto@xlerion.com" className="text-indigo-400 hover:text-indigo-300 underline">contacto@xlerion.com</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {/* Technical Documentation Authentication Modal */}
            {showTechDocAuth && (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
                    <div className="bg-gray-900 border-2 border-blue-600/50 rounded-lg max-w-md w-full">
                        <div className="p-6">
                            <div className="flex items-center justify-between mb-6">
                                <div className="flex items-center gap-3">
                                    <span className="text-4xl">🔒</span>
                                    <div>
                                        <h2 className="text-2xl font-bold text-blue-400">Acceso Restringido</h2>
                                        <p className="text-sm text-gray-400 mt-1">Documento Técnico Industrial</p>
                                    </div>
                                </div>
                                <button
                                    onClick={() => { setShowTechDocAuth(false); setTechDocPassword(''); setTechDocAuthError(''); }}
                                    className="text-gray-400 hover:text-white transition-colors p-2 hover:bg-gray-800 rounded"
                                >
                                    <X size={24} />
                                </button>
                            </div>
                            <div className="space-y-4">
                                <div className="bg-yellow-900/20 border-l-4 border-yellow-500 p-4 rounded">
                                    <p className="text-sm text-gray-300">
                                        <strong className="text-yellow-400">⚠️ Contenido Confidencial</strong><br />
                                        Información técnica propietaria de <strong>XLERION</strong>. Requiere autenticación.
                                    </p>
                                </div>
                                <div>
                                    <label className="block text-sm font-semibold text-blue-300 mb-2">🔐 Contraseña:</label>
                                    <input
                                        type="password"
                                        value={techDocPassword}
                                        onChange={(e) => { setTechDocPassword(e.target.value); setTechDocAuthError(''); }}
                                        placeholder="Ingrese la contraseña"
                                        className="w-full px-4 py-3 bg-gray-800/70 border border-blue-600/40 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/50"
                                        onKeyPress={(e) => { if (e.key === 'Enter' && techDocPassword.length > 0) { document.querySelector('[data-auth-submit]').click(); } }}
                                        autoFocus
                                    />
                                </div>
                                {techDocAuthError && (
                                    <div className="bg-red-900/30 border border-red-600/40 rounded-lg p-3 text-sm text-red-400 flex items-start gap-2">
                                        <span>❌</span><span>{techDocAuthError}</span>
                                    </div>
                                )}
                                <button
                                    data-auth-submit
                                    onClick={() => {
                                        const correctPassword = import.meta.env.VITE_TECHNICAL_DOC_PASSWORD || '81720164';
                                        if (techDocPassword === correctPassword) {
                                            setTechDocAuthError(''); setShowTechDocAuth(false); setShowTechnicalDoc(true); setTechDocPassword('');
                                        } else if (techDocPassword.length === 0) {
                                            setTechDocAuthError('Por favor ingrese la contraseña');
                                        } else {
                                            setTechDocAuthError('Contraseña incorrecta. Contacte a XLERION (contacto@xlerion.com)');
                                        }
                                    }}
                                    disabled={techDocPassword.length === 0}
                                    className="w-full px-6 py-4 bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-700 hover:to-cyan-700 disabled:from-gray-600 disabled:to-gray-700 disabled:cursor-not-allowed disabled:opacity-50 rounded-lg font-bold text-white text-lg transition-all flex items-center justify-center gap-3 shadow-lg hover:shadow-xl"
                                >
                                    <span className="text-2xl">🔓</span>Acceder al Documento
                                </button>
                                <div className="text-xs text-gray-500 text-center pt-2">
                                    ¿No tiene acceso? Contacte a <a href="mailto:contacto@xlerion.com" className="text-blue-400 hover:text-blue-300 underline">contacto@xlerion.com</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {/* Algorithm Modal - Simplified Version */}
            {showAlgorithm && (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
                    <div className="bg-gray-900 border-2 border-indigo-600/50 rounded-lg max-w-5xl w-full max-h-[90vh] overflow-y-auto">
                        <div className="sticky top-0 bg-gray-900 z-10 border-b border-indigo-600/30 p-6">
                            <div className="flex justify-between items-center">
                                <div className="flex items-center gap-3">
                                    <span className="text-4xl">💡</span>
                                    <div>
                                        <h2 className="text-2xl font-bold text-indigo-400">Algoritmo de GreenWave</h2>
                                        <p className="text-sm text-gray-400 mt-1">Sistema Inteligente de Gestión Adaptativa de Tráfico</p>
                                    </div>
                                </div>
                                <button onClick={() => setShowAlgorithm(false)} className="text-gray-400 hover:text-white transition-colors p-2 hover:bg-gray-800 rounded">
                                    <X size={24} />
                                </button>
                            </div>
                        </div>
                        <div className="p-8 space-y-6">
                            <div className="bg-indigo-950/30 border-l-4 border-indigo-500 rounded p-4">
                                <p className="text-xs text-gray-400">
                                    <strong className="text-indigo-400">© 2015-2026 XLERION</strong> - Propiedad intelectual protegida. Distribución no autorizada constituye violación de derechos de autor.
                                </p>
                            </div>
                            <section>
                                <h3 className="text-xl font-bold text-indigo-400 mb-4">1. RESUMEN</h3>
                                <p className="text-gray-300 leading-relaxed">
                                    El algoritmo <strong className="text-indigo-400">Xlerion GreenWave</strong> optimiza el flujo vehicular mediante decisiones adaptativas en tiempo real,
                                    analizando constantemente el tráfico y asignando dinámicamente el paso a las direcciones más congestionadas.
                                </p>
                            </section>
                            <section>
                                <h3 className="text-xl font-bold text-indigo-400 mb-4">2. LÓGICA CENTRAL</h3>
                                <div className="bg-gray-800/50 border border-indigo-600/20 rounded p-4">
                                    <pre className="text-xs text-cyan-400 overflow-x-auto bg-gray-900/50 p-3 rounded whitespace-pre-wrap">
                                        {`// Selección de dirección prioritaria
const directions = [{dir:'N',count:waiting.N}, {dir:'S',count:waiting.S}, 
                    {dir:'E',count:waiting.E}, {dir:'W',count:waiting.W}];

// Filtrar direcciones con tráfico no servidas
let available = directions.filter(d => d.count > 0 && !servedDirections.includes(d.dir));
if (available.length === 0) { servedDirections = []; available = directions.filter(d => d.count > 0); }

// Ordenar por congestión y seleccionar
available.sort((a,b) => b.count - a.count);
const mostCongested = available[0];

// Liberar hasta 50 vehículos (anti-monopolización)
targetToRelease = Math.min(50, mostCongested.count);
servedDirections.push(mostCongested.dir);`}
                                    </pre>
                                </div>
                            </section>
                            <section>
                                <h3 className="text-xl font-bold text-indigo-400 mb-4">3. INNOVACIONES CLAVE</h3>
                                <div className="space-y-3">
                                    <div className="bg-purple-900/20 border-l-4 border-purple-500 p-4 rounded">
                                        <p className="font-semibold text-purple-400 mb-1">🎯 Array servedDirections[]</p>
                                        <p className="text-xs text-gray-300">Garantiza rotación justa: ninguna dirección se monopoliza, todas reciben su turno.</p>
                                    </div>
                                    <div className="bg-cyan-900/20 border-l-4 border-cyan-500 p-4 rounded">
                                        <p className="font-semibold text-cyan-400 mb-1">📊 Métricas Temporales</p>
                                        <p className="text-xs text-gray-300">Mide eficiencia por tiempo de espera y uso efectivo del verde, no solo cantidad de vehículos.</p>
                                    </div>
                                    <div className="bg-yellow-900/20 border-l-4 border-yellow-500 p-4 rounded">
                                        <p className="font-semibold text-yellow-400 mb-1">⚡ Cuota de 50 Vehículos</p>
                                        <p className="text-xs text-gray-300">Límite duro anti-monopolización incluso bajo congestión extrema.</p>
                                    </div>
                                </div>
                            </section>
                            <section>
                                <h3 className="text-xl font-bold text-indigo-400 mb-4">4. COMPARACIÓN</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="bg-green-900/20 border border-green-600/30 rounded p-4">
                                        <h5 className="font-bold text-green-400 mb-3">🟢 GreenWave</h5>
                                        <ul className="text-xs text-gray-300 space-y-2">
                                            <li>✅ Fase adaptativa según tráfico real</li>
                                            <li>✅ Rotación justa garantizada</li>
                                            <li>✅ Espera: 5-8 seg | Verde efectivo: 85-95%</li>
                                        </ul>
                                    </div>
                                    <div className="bg-red-900/20 border border-red-600/30 rounded p-4">
                                        <h5 className="font-bold text-red-400 mb-3">🔴 Tradicional</h5>
                                        <ul className="text-xs text-gray-300 space-y-2">
                                            <li>❌ Fases fijas (60 ticks)</li>
                                            <li>❌ Monopolización de vías</li>
                                            <li>❌ Espera: 12-18 seg | Verde efectivo: 40-60%</li>
                                        </ul>
                                    </div>
                                </div>
                            </section>
                            <div className="text-center text-xs text-gray-500 pt-4">
                                © 2015-2026 XLERION | <a href="mailto:contacto@xlerion.com" className="text-indigo-400 hover:underline">contacto@xlerion.com</a>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {/* Technical Documentation Modal - Simplified */}
            {showTechnicalDoc && (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
                    <div className="bg-gray-900 border-2 border-blue-600/50 rounded-lg max-w-6xl w-full max-h-[90vh] overflow-y-auto">
                        <div className="sticky top-0 bg-gray-900 z-10 border-b border-blue-600/30 p-6">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h2 className="text-2xl font-bold text-blue-400">Documento Técnico Industrial</h2>
                                    <p className="text-sm text-gray-400 mt-1">Xlerion GreenWave - Sistema Inteligente de Gestión de Tráfico</p>
                                </div>
                                <button onClick={() => setShowTechnicalDoc(false)} className="text-gray-400 hover:text-white transition-colors p-2 hover:bg-gray-800 rounded">
                                    <X size={24} />
                                </button>
                            </div>
                        </div>
                        <div className="p-8 space-y-8">
                            <div className="bg-blue-950/30 border border-blue-600/30 rounded-lg p-6">
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                    <div><span className="text-blue-400 font-semibold">Documento:</span><p className="text-gray-300 mt-1">XGW-TECH-DOC-v1.0</p></div>
                                    <div><span className="text-blue-400 font-semibold">Fecha:</span><p className="text-gray-300 mt-1">Enero 2026</p></div>
                                    <div><span className="text-blue-400 font-semibold">Clasificación:</span><p className="text-yellow-400 mt-1 font-bold">⚠️ CONFIDENCIAL</p></div>
                                    <div><span className="text-blue-400 font-semibold">Empresa:</span><p className="text-gray-300 mt-1">XLERION</p></div>
                                </div>
                            </div>
                            <section>
                                <h3 className="text-xl font-bold text-blue-400 mb-4">1. RESUMEN EJECUTIVO</h3>
                                <p className="text-gray-300 leading-relaxed">
                                    <strong className="text-blue-400">Xlerion GreenWave</strong> reduce tiempos de espera vehicular en <strong>40-60%</strong> comparado con sistemas tradicionales,
                                    disminuyendo emisiones de CO₂ y mejorando la experiencia ciudadana.
                                </p>
                            </section>
                            <section>
                                <h3 className="text-xl font-bold text-blue-400 mb-4">2. STACK TECNOLÓGICO</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="bg-gray-800/50 border border-blue-600/20 rounded-lg p-4">
                                        <div className="text-3xl mb-2">⚛️</div>
                                        <h5 className="font-bold text-white">React 19 + Vite 7</h5>
                                        <p className="text-xs text-gray-400 mt-1">Virtual DOM, HMR instantáneo, build optimizado</p>
                                    </div>
                                    <div className="bg-gray-800/50 border border-blue-600/20 rounded-lg p-4">
                                        <div className="text-3xl mb-2">🎨</div>
                                        <h5 className="font-bold text-white">Tailwind CSS 3</h5>
                                        <p className="text-xs text-gray-400 mt-1">Utility-first, responsive, ~15KB gzipped</p>
                                    </div>
                                    <div className="bg-gray-800/50 border border-blue-600/20 rounded-lg p-4">
                                        <div className="text-3xl mb-2">🎮</div>
                                        <h5 className="font-bold text-white">Three.js r182</h5>
                                        <p className="text-xs text-gray-400 mt-1">Renderizado 3D, WebGL, visualización inmersiva</p>
                                    </div>
                                    <div className="bg-gray-800/50 border border-blue-600/20 rounded-lg p-4">
                                        <div className="text-3xl mb-2">📊</div>
                                        <h5 className="font-bold text-white">SVG + Canvas</h5>
                                        <p className="text-xs text-gray-400 mt-1">Gráficos escalables, animaciones GPU</p>
                                    </div>
                                </div>
                            </section>
                            <section>
                                <h3 className="text-xl font-bold text-blue-400 mb-4">3. PERFORMANCE</h3>
                                <div className="bg-blue-950/50 border-l-4 border-blue-500 p-4 rounded">
                                    <p className="text-sm text-gray-300">
                                        <strong className="text-blue-300">Optimización:</strong> Complejidad O(1) constante, overhead &lt;1% CPU,
                                        actualizaciones cada 50ms sin degradación. Chunk splitting reduce bundle size en 40%.
                                    </p>
                                </div>
                            </section>
                            <div className="text-center text-xs text-gray-500 pt-4">
                                © 2015-2026 XLERION | Confidencial | <a href="mailto:contacto@xlerion.com" className="text-blue-400 hover:underline">contacto@xlerion.com</a>
                            </div>
                        </div>
                    </div>
                </div>
            )}

            {/* IP Protection / Copyright Modal */}
            {showIPProtection && (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
                    <div className="bg-gray-900 border-2 border-purple-600/50 rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
                        <div className="sticky top-0 bg-gray-900 z-10 border-b border-purple-600/30 p-6">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h2 className="text-2xl font-bold text-purple-400">© DERECHOS DE AUTOR Y PROTECCIÓN LEGAL</h2>
                                    <p className="text-sm text-gray-400 mt-1">XLERION GREENWAVE™ - Propiedad Intelectual Protegida</p>
                                </div>
                                <button onClick={() => setShowIPProtection(false)} className="text-gray-400 hover:text-white transition-colors p-2 hover:bg-gray-800 rounded">
                                    <X size={24} />
                                </button>
                            </div>
                        </div>
                        <div className="p-8 space-y-6">
                            <div className="bg-purple-900/20 border-2 border-purple-600/30 rounded-lg p-6">
                                <h3 className="text-xl font-bold text-purple-400 mb-4">© AVISO DE DERECHOS DE AUTOR</h3>
                                <div className="space-y-3 text-gray-300 text-sm">
                                    <p className="font-bold text-purple-300">Copyright © 2015-2026 XLERION - Todos los Derechos Reservados</p>
                                    <p>
                                        <strong className="text-purple-400">Titular:</strong> XLERION (www.xlerion.com)<br />
                                        <strong className="text-purple-400">Obra:</strong> XLERION GREENWAVE™ - Sistema Inteligente de Gestión de Tráfico<br />
                                        <strong className="text-purple-400">Jurisdicción:</strong> República de Colombia y Tratados Internacionales
                                    </p>
                                    <p className="text-red-400 font-semibold">⚠️ ADVERTENCIA LEGAL: Protegido por Ley 23/1982, Ley 44/1993, Decisión Andina 351, Convenio de Berna, ADPIC/TRIPS.</p>
                                </div>
                            </div>
                            <div className="bg-red-900/20 border-2 border-red-600/30 rounded-lg p-6">
                                <h3 className="text-xl font-bold text-red-400 mb-4">⚖️ MARCO LEGAL</h3>
                                <div className="space-y-4 text-gray-300 text-sm">
                                    <div>
                                        <p className="font-bold text-red-300 mb-2">1. DERECHOS DE AUTOR (Software)</p>
                                        <ul className="list-disc list-inside space-y-1 text-xs ml-4">
                                            <li><strong>Ley 23/1982:</strong> Protección automática. Duración: vida + 80 años</li>
                                            <li><strong>Ley 44/1993:</strong> Software como obra literaria</li>
                                            <li><strong>Decisión Andina 351:</strong> Protección regional (CAN)</li>
                                        </ul>
                                    </div>
                                    <div>
                                        <p className="font-bold text-red-300 mb-2">2. PROPIEDAD INDUSTRIAL</p>
                                        <ul className="list-disc list-inside space-y-1 text-xs ml-4">
                                            <li><strong>Decisión Andina 486:</strong> Patentes de invención</li>
                                            <li><strong>Ley 1753/2015:</strong> Innovación tecnológica</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div className="bg-orange-900/20 border-2 border-orange-600/30 rounded-lg p-6">
                                <h3 className="text-xl font-bold text-orange-400 mb-4">🚫 USOS PROHIBIDOS</h3>
                                <ul className="space-y-2 text-xs text-gray-300">
                                    <li className="flex gap-2"><span className="text-red-500">❌</span> Reproducción, copia, modificación del código o algoritmos</li>
                                    <li className="flex gap-2"><span className="text-red-500">❌</span> Implementación comercial sin licencia</li>
                                    <li className="flex gap-2"><span className="text-red-500">❌</span> Ingeniería inversa, decompilación</li>
                                    <li className="flex gap-2"><span className="text-red-500">❌</span> Uso de marca GREENWAVE™ sin autorización</li>
                                    <li className="flex gap-2"><span className="text-red-500">❌</span> Presentación como invención propia</li>
                                </ul>
                            </div>
                            <div className="bg-red-950/40 border-2 border-red-700/50 rounded-lg p-6">
                                <h3 className="text-xl font-bold text-red-400 mb-4">⚠️ SANCIONES</h3>
                                <div className="grid md:grid-cols-2 gap-4 text-xs">
                                    <div className="bg-black/40 p-4 rounded border border-red-600/30">
                                        <p className="font-bold text-red-400 mb-2">CIVILES:</p>
                                        <ul className="list-disc list-inside space-y-1"><li>Indemnización daños y perjuicios</li><li>Lucro cesante</li><li>Medidas cautelares</li></ul>
                                    </div>
                                    <div className="bg-black/40 p-4 rounded border border-red-600/30">
                                        <p className="font-bold text-red-400 mb-2">PENALES:</p>
                                        <ul className="list-disc list-inside space-y-1"><li>Art. 271 CP: Prisión 4-8 años</li><li>Multas hasta 300 SMLMV</li></ul>
                                    </div>
                                </div>
                            </div>
                            <div className="bg-green-900/20 border-2 border-green-600/30 rounded-lg p-6">
                                <h3 className="text-xl font-bold text-green-400 mb-4">✅ LICENCIAMIENTO</h3>
                                <p className="text-gray-300 text-sm mb-3">Para implementar XLERION GREENWAVE™ contacte:</p>
                                <div className="bg-black/40 p-4 rounded border border-green-600/20">
                                    <p className="font-mono text-green-400">
                                        <strong>XLERION</strong><br />
                                        🌐 <a href="https://xlerion.com" target="_blank" rel="noopener" className="underline hover:text-green-300">www.xlerion.com</a><br />
                                        📧 contacto@xlerion.com<br />
                                        📍 Colombia
                                    </p>
                                </div>
                            </div>
                            <div className="bg-gray-800/50 border border-gray-600/30 rounded-lg p-4">
                                <p className="text-xs text-gray-400 text-center font-mono">
                                    🔐 Digital Watermark: XLERION-GREENWAVE-{new Date().getFullYear()}-{Math.random().toString(36).substring(2, 10).toUpperCase()}<br />
                                    Timestamp: {new Date().toISOString()} | SHA-256 Protected
                                </p>
                            </div>
                        </div>
                        <button onClick={() => setShowIPProtection(false)} className="w-full bg-purple-600 hover:bg-purple-500 text-white px-4 py-3 rounded-b-lg font-bold transition-colors">
                            He Leído y Comprendo la Protección Legal
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
}
